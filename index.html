<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4D36DBYDJX"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4D36DBYDJX');
    </script>
    <title>unitale</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        .thinking { color: #6b7280; font-style: italic; background: #f3f4f6; padding: 12px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid #d1d5db; font-size: 0.9rem; }
        .result-box { line-height: 1.6; font-size: 1rem; color: #1f2937; }
    </style>
</head>
<body class="bg-slate-50 p-4 md:p-8">
    <div id="app" class="w-full max-w-[96%] mx-auto bg-white p-6 rounded-2xl shadow-xl border border-slate-200">
        <header class="mb-6 flex justify-between items-end">
            <div>
                <h1 class="text-2xl font-bold text-slate-800">Unitale <span class="text-blue-600">1.2</span></h1>
                <p class="text-slate-400 text-xs mt-1">多角色音效有声书生成工具</p>
            </div>
            <div class="text-[10px] text-slate-300">v1.2</div>
        </header>
        
        <!-- 标签页导航 -->
        <div class="flex border-b border-slate-200 mb-6">
            <button @click="activeTab = 'config'" :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'config' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                模型配置
            </button>
            <button @click="activeTab = 'timbres'" :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'timbres' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                音色资源库
            </button>
            <button @click="activeTab = 'sfx'" :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'sfx' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                音效与滤波器
            </button>
            <button @click="activeTab = 'script'" :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'script' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                脚本制作
            </button>
            <button @click="activeTab = 'prompt'" :class="['px-6 py-3 text-sm font-bold transition-colors', activeTab === 'prompt' ? 'text-blue-600 border-b-2 border-blue-600' : 'text-slate-500 hover:text-slate-700']">
                Prompt 管理
            </button>
        </div>

        <!-- 页面 1: 模型配置 (LLM & TTS) -->
        <div v-if="activeTab === 'config'" class="space-y-6">
            <h2 class="text-lg font-bold text-slate-800 border-b pb-2">LLM 模型配置（OpenAI通用接口）</h2>
            <!-- 添加/编辑表单 -->
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditing ? '编辑配置' : '添加新配置' }}</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">配置名称</label>
                        <input v-model="form.name" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: Google Gemini">
                    </div>
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">模型名称</label>
                        <input v-model="form.model" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="gemini-2.5-flash">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">Base URL</label>
                        <input v-model="form.baseUrl" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="https://generativelanguage.googleapis.com/v1beta/openai">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">API Key</label>
                        <input v-model="form.key" type="password" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="sk-...">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">额外参数 (JSON格式，可选)</label>
                        <input v-model="form.params" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder='例如: {"temperature": 0.7, "max_tokens": 2000}'>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button type="button" @click.prevent="saveConfig" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">保存配置</button>
                    <button type="button" v-if="isEditing" @click="resetForm" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">取消</button>
                </div>
            </div>

            <!-- 配置列表 -->
            <div class="grid gap-3">
                <div v-for="conf in llmConfigs" :key="conf.id" class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                    <div>
                        <div class="font-bold text-slate-800 text-sm">{{ conf.name }}</div>
                        <div class="text-xs text-slate-400 mt-1">{{ conf.model }} | {{ conf.baseUrl }}</div>
                    </div>
                    <div class="flex gap-2">
                        <button @click="editConfig(conf)" class="text-xs text-blue-600 hover:underline font-medium">编辑</button>
                        <button @click="deleteConfig(conf.id)" class="text-xs text-red-500 hover:underline font-medium">删除</button>
                    </div>
                </div>
                <div v-if="llmConfigs.length === 0" class="text-center py-8 text-slate-400 text-sm">
                    暂无配置，请在上方添加
                </div>
            </div>
            
            <h2 class="text-lg font-bold text-slate-800 border-b pb-2 pt-6">TTS 语音合成配置</h2>
            <!-- 添加/编辑表单 -->
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingTts ? '编辑 TTS 配置' : '添加新 TTS 配置' }}</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">配置名称</label>
                        <input v-model="ttsForm.name" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: IndexTTS 2">
                    </div>
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">Base URL</label>
                        <input v-model="ttsForm.baseUrl" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="http://127.0.0.1:8300">
                    </div>
                </div>
                <div class="flex gap-2">
                    <button type="button" @click.prevent="saveTtsConfig" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">保存配置</button>
                    <button type="button" v-if="isEditingTts" @click="resetTtsForm" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">取消</button>
                </div>
            </div>

            <!-- 配置列表 -->
            <div class="grid gap-3">
                <div v-for="conf in ttsConfigs" :key="conf.id" class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                    <div>
                        <div class="font-bold text-slate-800 text-sm">{{ conf.name }}</div>
                        <div class="text-xs text-slate-400 mt-1">{{ conf.baseUrl }}</div>
                    </div>
                    <div class="flex gap-2">
                        <button @click="editTtsConfig(conf)" class="text-xs text-blue-600 hover:underline font-medium">编辑</button>
                        <button @click="deleteTtsConfig(conf.id)" class="text-xs text-red-500 hover:underline font-medium">删除</button>
                    </div>
                </div>
                <div v-if="ttsConfigs.length === 0" class="text-center py-8 text-slate-400 text-sm">
                    暂无 TTS 配置，请在上方添加
                </div>
            </div>
        </div>

        <!-- 页面 4: 音色资源库 -->
        <div v-if="activeTab === 'timbres'" class="space-y-8">
            <!-- 音色管理区域 -->
            <section class="space-y-6">
            <h2 class="text-lg font-bold text-slate-800 border-b pb-2">音色管理</h2>
            <!-- 添加/编辑表单 -->
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingTimbre ? '编辑音色' : '添加新音色' }}</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">目标 TTS 服务 (用于上传音频)</label>
                        <select v-model="currentTtsConfigId" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white">
                            <option value="" disabled>-- 请选择 TTS 模型 --</option>
                            <option v-for="conf in ttsConfigs" :key="conf.id" :value="conf.id">
                                {{ conf.name }} ({{ conf.baseUrl }})
                            </option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">音色名称</label>
                        <input v-model="timbreForm.name" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 旁白 / 少年音">
                    </div>
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">音色描述 (用于 AI 自动匹配)</label>
                        <input v-model="timbreForm.description" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 声音低沉，适合反派或中年男性">
                    </div>
                    <div class="md:col-span-2">
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">参考音频文件</label>
                        <div class="flex gap-2 items-center">
                            <input type="file" ref="timbreFileRef" @change="handleTimbreFileUpload" accept=".wav,.mp3" class="hidden">
                            <button type="button" @click="$refs.timbreFileRef.click()" class="whitespace-nowrap px-3 py-2 bg-slate-100 border border-slate-300 text-slate-600 rounded-lg text-xs hover:bg-slate-200 transition-colors">选择文件</button>
                            <input v-model="timbreForm.refPath" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="选择一个音频文件作为音色参考">
                        </div>
                        <p class="text-[10px] text-slate-400 mt-1">提示：选择的音频文件将被上传至 TTS 服务器作为音色参考。请确保TTS服务器已启动。</p>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button type="button" @click.prevent="saveTimbre" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">保存音色</button>
                    <button type="button" v-if="isEditingTimbre" @click="resetTimbreForm" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">取消</button>
                </div>
            </div>

            <!-- 音色列表 -->
            <div class="grid gap-3">
                <div v-for="timbre in timbres" :key="timbre.id" class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 rounded-full bg-indigo-100 text-indigo-600 flex items-center justify-center font-bold text-lg">
                            {{ timbre.name.charAt(0) }}
                        </div>
                        <div>
                            <div class="font-bold text-slate-800 text-sm">{{ timbre.name }}</div>
                            <div v-if="timbre.description" class="text-xs text-slate-500 mt-0.5">{{ timbre.description }}</div>
                            <div class="text-xs text-slate-400 mt-1">{{ timbre.refPath }}</div>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button @click="playPreview(timbre.refPath)" class="text-xs text-slate-400 hover:text-green-600 mr-1" title="试听">
                            <svg v-if="previewPlayingFile === timbre.refPath" class="h-4 w-4 text-green-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                            <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                        </button>
                        <button @click="editTimbre(timbre)" class="text-xs text-blue-600 hover:underline font-medium">编辑</button>
                        <button @click="deleteTimbre(timbre.id)" class="text-xs text-red-500 hover:underline font-medium">删除</button>
                    </div>
                </div>
                <div v-if="timbres.length === 0" class="text-center py-8 text-slate-400 text-sm">
                    暂无音色，请在上方添加
                </div>
            </div>
            </section>

            <!-- 情绪向量预设区域 -->
            <section class="space-y-6">
            <h2 class="text-lg font-bold text-slate-800 border-b pb-2">情绪描述预设</h2>
            <!-- 添加/编辑情绪表单 -->
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingEmotion ? '编辑情绪预设' : '添加新情绪预设' }}</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">情绪名称</label>
                        <input v-model="emotionForm.name" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 开心 / 愤怒">
                    </div>
                    <div>
                        <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">情绪描述文本</label>
                        <input v-model="emotionForm.text" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 悲伤，带着哭腔">
                    </div>
                </div>
                <div class="flex gap-2">
                    <button type="button" @click.prevent="saveEmotion" class="px-4 py-2 bg-green-600 text-white rounded-lg text-xs font-bold hover:bg-green-700 transition-all">保存情绪</button>
                    <button type="button" v-if="isEditingEmotion" @click="resetEmotionForm" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">取消</button>
                    <button type="button" @click="resetEmotionsToDefault" class="px-4 py-2 bg-slate-100 text-slate-500 rounded-lg text-xs font-bold hover:bg-slate-200 transition-all ml-auto">恢复默认预设</button>
                </div>
            </div>

            <!-- 情绪列表 -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                <div v-for="emo in emotionPresets" :key="emo.id" class="p-3 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow flex justify-between items-center">
                    <div>
                        <div class="font-bold text-slate-800 text-sm">{{ emo.name }}</div>
                        <div class="text-[10px] text-slate-400 mt-1 truncate w-48">{{ emo.text }}</div>
                    </div>
                    <div class="flex gap-2">
                        <button @click="editEmotion(emo)" class="text-xs text-blue-600 hover:underline">编辑</button>
                        <button @click="deleteEmotion(emo.id)" class="text-xs text-red-500 hover:underline">删除</button>
                    </div>
                </div>
            </div>
            </section>
        </div>

        <!-- 页面 6: 音效素材库 -->
        <div v-if="activeTab === 'sfx'" class="space-y-8">
            <section class="space-y-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">音效素材管理</h2>
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingSfx ? '编辑音效' : '添加新音效' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">音效名称</label>
                            <input v-model="sfxForm.name" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 开门声 / 雷声">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">音效描述 (用于 AI 判断插入)</label>
                            <input v-model="sfxForm.description" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 沉重的木门被用力关上">
                        </div>
                        <div class="md:col-span-2">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">音频文件名 / 路径</label>
                            <div class="flex gap-2 items-center">
                                <input type="file" ref="sfxFileRef" @change="handleSfxFileUpload" accept=".wav,.mp3" class="hidden">
                                <button type="button" @click="$refs.sfxFileRef.click()" class="whitespace-nowrap px-3 py-2 bg-slate-100 border border-slate-300 text-slate-600 rounded-lg text-xs hover:bg-slate-200 transition-colors">选择文件</button>
                                <input v-model="sfxForm.filename" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: door_slam.wav">
                            </div>
                            <p class="text-[10px] text-slate-400 mt-1"></p>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveSfx" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">保存音效</button>
                        <button type="button" v-if="isEditingSfx" @click="resetSfxForm" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">取消</button>
                    </div>
                </div>

                <div class="grid gap-3">
                    <div v-for="sfx in sfxLibrary" :key="sfx.id" class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                        <div class="flex items-center gap-3">
                        <input type="checkbox" v-model="sfx.enabled" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer" title="启用/禁用此资源">
                        <div>
                            <div class="font-bold text-slate-800 text-sm">{{ sfx.name }}</div>
                            <div class="text-xs text-slate-500 mt-0.5">{{ sfx.description }}</div>
                            <div class="text-xs text-slate-400 mt-1">{{ sfx.filename }}</div>
                        </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="playPreview(sfx.filename)" class="text-xs text-slate-400 hover:text-green-600 mr-1" title="试听">
                                <svg v-if="previewPlayingFile === sfx.filename" class="h-4 w-4 text-green-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                                <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                            </button>
                            <button @click="editSfx(sfx)" class="text-xs text-blue-600 hover:underline font-medium">编辑</button>
                            <button @click="deleteSfx(sfx.id)" class="text-xs text-red-500 hover:underline font-medium">删除</button>
                        </div>
                    </div>
                    <div v-if="sfxLibrary.length === 0" class="text-center py-8 text-slate-400 text-sm">暂无音效素材</div>
                </div>
            </section>

            <section class="space-y-6 border-t border-slate-200 pt-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">背景音乐管理 (BGM)</h2>
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingBgm ? '编辑 BGM' : '添加新 BGM' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">BGM 名称</label>
                            <input v-model="bgmForm.name" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 悲伤钢琴 / 战斗激昂">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">BGM 描述 (用于 AI 判断)</label>
                            <input v-model="bgmForm.description" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 适合悲伤场景的钢琴曲">
                        </div>
                        <div class="md:col-span-2">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">音频文件名 / 路径</label>
                            <div class="flex gap-2 items-center">
                                <input type="file" ref="bgmFileRef" @change="handleBgmFileUpload" accept=".wav,.mp3" class="hidden">
                                <button type="button" @click="$refs.bgmFileRef.click()" class="whitespace-nowrap px-3 py-2 bg-slate-100 border border-slate-300 text-slate-600 rounded-lg text-xs hover:bg-slate-200 transition-colors">选择文件</button>
                                <input v-model="bgmForm.filename" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: sad_piano.mp3">
                            </div>
                            <p class="text-[10px] text-slate-400 mt-1"></p>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveBgm" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">保存 BGM</button>
                        <button type="button" v-if="isEditingBgm" @click="resetBgmForm" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">取消</button>
                    </div>
                </div>

                <div class="grid gap-3">
                    <div v-for="bgm in bgmLibrary" :key="bgm.id" class="flex items-center justify-between p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow">
                        <div class="flex items-center gap-3">
                        <input type="checkbox" v-model="bgm.enabled" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer" title="启用/禁用此资源">
                        <div>
                            <div class="font-bold text-slate-800 text-sm">{{ bgm.name }}</div>
                            <div class="text-xs text-slate-500 mt-0.5">{{ bgm.description }}</div>
                            <div class="text-xs text-slate-400 mt-1">{{ bgm.filename }}</div>
                        </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="playPreview(bgm.filename)" class="text-xs text-slate-400 hover:text-green-600 mr-1" title="试听">
                                <svg v-if="previewPlayingFile === bgm.filename" class="h-4 w-4 text-green-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                                <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                            </button>
                            <button @click="editBgm(bgm)" class="text-xs text-blue-600 hover:underline font-medium">编辑</button>
                            <button @click="deleteBgm(bgm.id)" class="text-xs text-red-500 hover:underline font-medium">删除</button>
                        </div>
                    </div>
                    <div v-if="bgmLibrary.length === 0" class="text-center py-8 text-slate-400 text-sm">暂无 BGM 素材</div>
                </div>
            </section>

            <section class="space-y-6 border-t border-slate-200 pt-6">
                <h2 class="text-lg font-bold text-slate-800 border-b pb-2">音频滤波器管理</h2>
                <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-4">{{ isEditingFilter ? '编辑滤波器' : '添加新滤波器' }}</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">滤波器名称</label>
                            <input v-model="filterForm.name" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 电话音 / 水下">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">滤波器描述 (用于 AI 判断)</label>
                            <input v-model="filterForm.description" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none" placeholder="例如: 声音通过电话传输，频段变窄">
                        </div>
                        <div>
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">滤波器类型</label>
                            <select v-model="filterForm.type" class="w-full px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white">
                                <option value="lowpass">低通 (Lowpass) - 适合水下/闷声</option>
                                <option value="highpass">高通 (Highpass) - 适合收音机/尖锐</option>
                                <option value="bandpass">带通 (Bandpass) - 适合电话/对讲机</option>
                                <option value="distortion">失真 (Distortion) - 适合机器人/损坏设备</option>
                            </select>
                        </div>
                        <div v-if="filterForm.type !== 'distortion'">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">频率 (Hz): {{ filterForm.frequency }}</label>
                            <input type="range" v-model.number="filterForm.frequency" min="20" max="20000" step="10" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        </div>
                        <div v-if="filterForm.type !== 'distortion'">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">Q 值 (共振峰): {{ filterForm.Q }}</label>
                            <input type="range" v-model.number="filterForm.Q" min="0.1" max="20" step="0.1" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                        </div>
                        <div v-if="filterForm.type === 'distortion'">
                            <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">失真度 (Amount): {{ filterForm.gain }}</label>
                            <input type="range" v-model.number="filterForm.gain" min="0" max="1000" step="10" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-red-600">
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button type="button" @click.prevent="saveFilter" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">保存滤波器</button>
                        <button type="button" v-if="isEditingFilter" @click="resetFilterForm" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">取消</button>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                    <div v-for="filter in filterLibrary" :key="filter.id" class="p-4 bg-white border border-slate-200 rounded-xl hover:shadow-sm transition-shadow flex justify-between items-center">
                        <div class="flex items-center gap-3">
                        <input type="checkbox" v-model="filter.enabled" class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 cursor-pointer" title="启用/禁用此资源">
                        <div>
                            <div class="font-bold text-slate-800 text-sm">{{ filter.name }}</div>
                            <div class="text-xs text-slate-500 mt-0.5">{{ filter.description }}</div>
                            <div class="text-[10px] text-slate-400 mt-1 font-mono">{{ filter.type }} | {{ filter.type === 'distortion' ? `Amt:${filter.gain}` : `Freq:${filter.frequency}Hz` }}</div>
                        </div>
                        </div>
                        <div class="flex gap-2">
                            <button @click="editFilter(filter)" class="text-xs text-blue-600 hover:underline font-medium">编辑</button>
                            <button @click="deleteFilter(filter.id)" class="text-xs text-red-500 hover:underline font-medium">删除</button>
                        </div>
                    </div>
                    <div v-if="filterLibrary.length === 0" class="col-span-full text-center py-8 text-slate-400 text-sm">暂无滤波器，请添加</div>
                </div>
            </section>
        </div>

        <!-- 页面 5: 脚本制作 (重构：左右分栏) -->
        <div v-if="activeTab === 'script'" class="flex flex-col lg:flex-row gap-6 items-start">
            
            <!-- 左侧：角色与音色绑定栏 -->
            <div class="w-full lg:w-60 flex-shrink-0 space-y-4">
                <div class="bg-slate-100 p-4 rounded-xl border border-slate-200">
                    <h3 class="text-sm font-bold text-slate-700 mb-3 flex justify-between items-center">
                        角色列表
                        <button @click="addCharacter" class="text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-700">+ 新增</button>
                    </h3>
                    <div class="space-y-3 max-h-[600px] overflow-y-auto pr-1">
                        <div v-for="char in characters" :key="char.id" class="bg-white p-3 rounded-lg border border-slate-200 shadow-sm text-sm space-y-2">
                            <div class="flex justify-between items-center">
                                <input v-model="char.name" class="font-bold text-slate-800 w-2/3 bg-transparent border-b border-transparent focus:border-blue-500 outline-none px-1" placeholder="角色名">
                                <button @click="deleteCharacter(char.id)" class="text-slate-400 hover:text-red-500">×</button>
                            </div>
                            
                            <div>
                                <label class="block text-[10px] font-bold text-slate-500 uppercase mb-1">音色选择</label>
                                <select v-model="char.voiceFile" class="w-full px-2 py-1.5 border rounded-md text-xs bg-white outline-none focus:ring-1 focus:ring-blue-500">
                                    <option value="">-- 请选择音色 --</option>
                                    <option v-for="timbre in timbres" :key="timbre.id" :value="timbre.refPath">
                                        {{ timbre.name }}
                                    </option>
                                </select>
                            </div>
                        </div>
                        <div v-if="characters.length === 0" class="text-center text-xs text-slate-400 py-4">暂无角色，请点击新增</div>
                    </div>
                </div>
            </div>

            <!-- 原文输入区域 -->
            <div class="flex-1 w-full space-y-6 min-w-0">
            <div class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-sm font-bold text-slate-700">1. 输入原文 / 小说片段</h3>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4 bg-slate-50 p-3 rounded-lg border border-slate-100">
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="text-[10px] font-bold text-slate-500 uppercase">全局感情强度</label>
                            <span class="text-xs font-bold text-blue-600 bg-blue-50 px-2 py-0.5 rounded">{{ emotionIntensity }} / 10</span>
                        </div>
                        <input v-model="emotionIntensity" type="range" min="1" max="10" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>
                    <div class="md:col-span-2 flex flex-wrap items-end gap-2 pb-1">
                        <button @click="exportScriptState" :disabled="isExportingProject" class="px-3 py-1.5 bg-amber-100 text-amber-700 rounded-lg text-xs font-bold hover:bg-amber-200 transition-all flex items-center gap-1 disabled:opacity-50 disabled:cursor-wait">
                            {{ isExportingProject ? exportStatus : '导出完整工程' }}
                        </button>
                        <button @click="triggerImport" :disabled="isExportingProject" class="px-3 py-1.5 bg-amber-100 text-amber-700 rounded-lg text-xs font-bold hover:bg-amber-200 transition-all flex items-center gap-1 disabled:opacity-50">
                            {{ isExportingProject ? '请等待...' : '导入完整工程' }}
                        </button>
                        <button @click="exportAudio" :disabled="isExportingAudio" class="px-3 py-1.5 bg-purple-100 text-purple-700 rounded-lg text-xs font-bold hover:bg-purple-200 transition-all flex items-center gap-1 disabled:opacity-50 disabled:cursor-wait">
                            {{ isExportingAudio ? '⏳ 处理中...' : '导出音频' }}
                        </button>
                        <input type="file" ref="importFileRef" @change="handleImportFile" accept=".json" class="hidden">
                    </div>
                </div>

                <textarea v-model="rawScript" class="w-full p-4 border rounded-xl h-48 mb-4 focus:ring-2 focus:ring-blue-500 outline-none resize-none bg-slate-50 text-sm leading-relaxed" placeholder="请粘贴小说内容或剧本原文..."></textarea>
                <div class="flex flex-wrap gap-2">
                    <select v-model="currentConfigId" class="px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white max-w-[180px]" title="选择用于分析的 LLM 模型">
                        <option value="" disabled>-- 选择LLM模型 --</option>
                        <option v-for="conf in llmConfigs" :key="conf.id" :value="conf.id">
                            {{ conf.name }}
                        </option>
                    </select>
                    <button @click="analyzeScript" :disabled="isAnalyzingScript" class="px-3 py-2 bg-indigo-600 text-white rounded-lg text-sm font-bold hover:bg-indigo-700 disabled:opacity-50 transition-all flex items-center">
                        <span v-if="isAnalyzingScript" class="animate-spin mr-2">⏳</span> {{ isAnalyzingScript ? 'AI 分析中...' : 'AI 深度分析' }}
                    </button>
                    <button @click="addDialogueBlock" class="px-2 py-2 bg-blue-100 text-blue-600 rounded-lg text-sm font-bold hover:bg-blue-200 transition-all">
                        ➕ 插入台词
                    </button>
                    <button @click="addBgmBlock" class="px-2 py-2 bg-purple-100 text-purple-600 rounded-lg text-sm font-bold hover:bg-purple-200 transition-all">
                        ➕ 插入BGM
                    </button>
                    <select v-model="currentTtsConfigId" class="px-3 py-2 border rounded-lg text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white max-w-[180px]" title="选择用于生成的 TTS 服务">
                        <option value="" disabled>-- 选择 TTS 模型 --</option>
                        <option v-for="conf in ttsConfigs" :key="conf.id" :value="conf.id">
                            {{ conf.name }}
                        </option>
                    </select>
                    <button @click="generateAllLines" :disabled="isGeneratingAll || isSequencePlaying" class="px-2 py-2 bg-green-600 text-white rounded-lg text-sm font-bold hover:bg-green-700 disabled:opacity-50 transition-all flex items-center">
                         <span v-if="isGeneratingAll" class="animate-spin mr-2">⏳</span> {{ isGeneratingAll ? '生成中...' : '生成全部台词音频' }}
                    </button>
                    <button v-if="!isSequencePlaying" @click="playScriptSequentially" class="px-2 py-2 bg-blue-600 text-white rounded-lg text-sm font-bold hover:bg-blue-700 disabled:opacity-50 transition-all">
                        {{ selectedLineIndex !== -1 ? '▶️ 从选中位置播放' : '▶️ 顺序播放' }}
                    </button>
                    <button v-else @click="stopScriptSequentially" class="px-6 py-2 bg-red-500 text-white rounded-lg text-sm font-bold hover:bg-red-600 transition-all">
                        停止播放
                    </button>
                    <div class="flex-grow"></div>
                </div>
            </div>

            <!-- 拆分结果列表 -->
            <div v-if="scriptLines.length > 0" class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-sm font-bold text-slate-700">2. 脚本台词列表 ({{ scriptLines.length }} 行)</h3>
                </div>
                <div class="space-y-3 max-h-[600px] overflow-y-auto px-2 pb-10">
                    <div v-for="(line, index) in scriptLines" :key="line.id" @click="selectedLineIndex = index" class="transition-all duration-200">
                        
                        <!-- BGM 控制块 -->
                        <div v-if="line.type === 'bgm'" :class="['flex items-center gap-3 p-3 rounded-lg border mb-2 transition-all', selectedLineIndex === index ? 'border-purple-500 bg-purple-50 shadow-md' : 'bg-purple-50/50 border-purple-200', currentSequenceIndex === index ? 'ring-2 ring-green-500' : '']">
                            <div class="flex flex-col items-center justify-center gap-1 w-8 flex-shrink-0 border-r border-purple-200 pr-2">
                                <button @click.stop="moveLineUp(index)" class="text-purple-400 hover:text-purple-700 p-0.5 hover:bg-purple-100 rounded" title="上移">▲</button>
                                <div class="text-xs font-bold text-purple-500 select-none">{{ index + 1 }}</div>
                                <button @click.stop="moveLineDown(index)" class="text-purple-400 hover:text-purple-700 p-0.5 hover:bg-purple-100 rounded" title="下移">▼</button>
                            </div>
                            <div class="w-24 flex-shrink-0 font-bold text-xs text-purple-600 uppercase tracking-wider flex items-center justify-center border-r border-purple-200 pr-3">
                                BGM 控制
                            </div>
                            <select v-model="line.action" class="w-24 px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-purple-500 outline-none font-bold text-purple-700">
                                <option value="play">▶ 播放</option>
                                <option value="stop">停止</option>
                            </select>
                            <div class="flex-1 flex items-center gap-2">
                                <select v-if="line.action === 'play'" v-model="line.bgmName" class="flex-1 px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-purple-500 outline-none font-bold text-purple-700">
                                    <option value="" disabled>-- 选择背景音乐 --</option>
                                    <option v-for="s in bgmLibrary" :key="s.id" :value="s.name">{{ s.name }}</option>
                                </select>
                                <div v-else class="flex-1 text-xs text-slate-400 italic py-1.5 px-2">停止当前播放的所有背景音乐</div>
                                <div v-if="line.action === 'play'" class="w-24 flex-shrink-0 space-y-1">
                                    <div class="text-[10px] font-bold text-slate-400 uppercase text-center leading-tight">BGM音量</div>
                                    <input type="range" v-model="line.volume" min="0" max="1" step="0.05" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-purple-600">
                                </div>
                            </div>
                            <button @click="removeScriptLine(index)" class="text-slate-300 hover:text-red-500 p-2"><svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg></button>
                        </div>

                        <!-- 台词块 -->
                        <div v-else :class="['flex flex-col gap-2 p-3 rounded-lg mb-2 transition-all group cursor-pointer border', selectedLineIndex === index ? 'bg-blue-50 border-blue-300 shadow-md' : 'bg-white border-slate-200 shadow-sm hover:bg-slate-50', currentSequenceIndex === index ? 'ring-2 ring-green-500' : '']">
                        <div class="flex flex-wrap items-stretch gap-3">
                        <div class="flex flex-col items-center justify-center gap-1 w-8 flex-shrink-0 border-r border-slate-100 pr-2">
                            <button @click.stop="moveLineUp(index)" class="text-slate-400 hover:text-blue-600 p-0.5 hover:bg-slate-100 rounded" title="上移">▲</button>
                            <div class="text-xs font-bold text-slate-400 select-none">{{ index + 1 }}</div>
                            <button @click.stop="moveLineDown(index)" class="text-slate-400 hover:text-blue-600 p-0.5 hover:bg-slate-100 rounded" title="下移">▼</button>
                        </div>
                        
                        <!-- 角色选择 -->
                        <div class="w-24 flex-shrink-0 flex flex-col justify-center gap-1">
                            <select v-model="line.role" class="w-full px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-blue-500 outline-none font-bold text-slate-700">
                                <option v-for="roleName in availableRoles" :key="roleName" :value="roleName">{{ roleName }}</option>
                            </select>
                            <!-- 滤波器选择 -->
                            <select v-model="line.filter" class="w-full px-2 py-1 text-[10px] border rounded bg-slate-50 focus:ring-1 focus:ring-blue-500 outline-none text-slate-500" title="音频滤波器">
                                <option value="">无滤波器</option>
                                <option v-for="f in filterLibrary" :key="f.id" :value="f.name">{{ f.name }}</option>
                            </select>
                        </div>

                        <!-- 情绪描述 -->
                        <div class="w-36 flex-shrink-0 space-y-1 flex flex-col justify-center">
                            <select :value="getEmotionSelectValue(line)" @change="applyPresetToLine(line, $event)" class="w-full px-2 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-blue-500 outline-none text-slate-600">
                                <option value="">AI生成</option>
                                <option v-for="preset in emotionPresets" :key="preset.id" :value="preset.text">{{ preset.name }}</option>
                                <option value="custom_option" disabled hidden></option>
                            </select>
                            <input v-model="line.emotion_text" class="w-full px-2 py-1 text-xs border rounded bg-white focus:ring-1 focus:ring-blue-500 outline-none text-slate-700" placeholder="情绪描述文本">
                        </div>

                        <!-- 停顿间隔 -->
                        <div class="w-16 flex-shrink-0 space-y-1 flex flex-col justify-center">
                            <div class="text-[10px] font-bold text-slate-400 uppercase text-center leading-tight">停顿(s)</div>
                            <input type="number" v-model="line.break_duration" step="0.1" min="0" class="w-full px-1 py-1.5 text-xs border rounded bg-white focus:ring-1 focus:ring-blue-500 outline-none text-center font-mono text-slate-600" placeholder="0">
                        </div>

                        <div class="flex-grow"></div>

                        <!-- 右侧控制区 -->
                        <div class="flex flex-col items-end gap-2">
                            <div class="flex items-center gap-3">
                                <!-- 音量控制 (加宽) -->
                                <div v-if="line.audioUrl" class="w-48 flex-shrink-0 flex flex-col justify-center gap-2 px-2 border-r border-slate-200">
                                    <div class="w-full">
                                        <div class="flex justify-between items-center mb-0.5">
                                            <span class="text-[8px] font-bold text-slate-400 uppercase">台词音量</span>
                                            <span class="text-[8px] text-slate-400 font-mono">{{ Math.round((line.dialogueVolume || 1) * 100) }}%</span>
                                        </div>
                                        <input type="range" v-model="line.dialogueVolume" min="0" max="1" step="0.05" class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-blue-600 block">
                                    </div>
                                    <div class="w-full">
                                        <div class="flex justify-between items-center mb-0.5">
                                            <span class="text-[8px] font-bold text-slate-400 uppercase">音效音量</span>
                                            <span class="text-[8px] text-slate-400 font-mono">{{ Math.round((line.sfxVolume || 0.5) * 100) }}%</span>
                                        </div>
                                        <input type="range" v-model="line.sfxVolume" min="0" max="1" step="0.05" class="w-full h-1.5 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600 block">
                                    </div>
                                </div>

                                <!-- 音频波形剪辑条 -->
                                <div v-if="line.audioUrl" class="w-48 flex-shrink-0 flex flex-col gap-1">
                                    <div class="flex justify-between items-center px-0.5">
                                        <span class="text-[8px] font-bold text-slate-400 uppercase">音频剪辑</span>
                                        <span class="text-[8px] text-slate-400 font-mono">{{ Math.round(((line.trimEnd||1) - (line.trimStart||0)) * 100) }}%</span>
                                    </div>
                                    <div :key="line.audioUrl" class="relative w-full bg-slate-100 rounded border border-slate-200 overflow-hidden select-none group/wave" style="height: 32px;">
                                    <canvas :ref="(el) => drawWaveform(el, line)" width="192" height="32" class="w-full h-full block opacity-60"></canvas>
                                    
                                    <!-- 遮罩层与手柄 -->
                                    <div class="absolute inset-0 pointer-events-none">
                                        <!-- 阴影遮罩 (被剪掉的部分) -->
                                        <div class="absolute top-0 bottom-0 left-0 bg-slate-500/30 border-r border-blue-500" :style="{ width: (line.trimStart || 0) * 100 + '%' }"></div>
                                        <div class="absolute top-0 bottom-0 right-0 bg-slate-500/30 border-l border-red-500" :style="{ width: (1 - (line.trimEnd || 1)) * 100 + '%' }"></div>
                                        
                                        <!-- 交互手柄 (扩大点击区域) -->
                                        <div class="absolute top-0 bottom-0 w-4 -ml-2 cursor-ew-resize pointer-events-auto hover:bg-blue-500/10 transition-colors flex justify-center group/handle" :style="{ left: (line.trimStart || 0) * 100 + '%' }" @mousedown.stop="startDragTrim($event, line, 'start')">
                                            <div class="w-0.5 h-full bg-blue-500 group-hover/handle:w-1 transition-all"></div>
                                        </div>
                                        <div class="absolute top-0 bottom-0 w-4 -ml-2 cursor-ew-resize pointer-events-auto hover:bg-red-500/10 transition-colors flex justify-center group/handle" :style="{ left: (line.trimEnd || 1) * 100 + '%' }" @mousedown.stop="startDragTrim($event, line, 'end')">
                                            <div class="w-0.5 h-full bg-red-500 group-hover/handle:w-1 transition-all"></div>
                                        </div>
                                        
                                        <!-- 播放进度条 -->
                                        <div v-if="isAuditioningId === line.id" class="absolute top-0 bottom-0 w-0.5 bg-green-500 z-20 pointer-events-none shadow-[0_0_4px_rgba(34,197,94,0.8)]" :style="{ left: (playbackProgress * 100) + '%' }"></div>
                                    </div>
                                    </div>
                                </div>

                                <!-- 按钮组 -->
                                <div class="flex items-center gap-1">
                                    <button @click.stop="generateLineAudio(line)" :disabled="line.isGenerating" title="生成音频" class="text-slate-400 hover:text-indigo-600 disabled:text-slate-300 disabled:cursor-wait p-2">
                                        <svg v-if="line.isGenerating" class="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                                        <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clip-rule="evenodd" /></svg>
                                    </button>
                                    <button v-if="line.audioUrl" @click.stop="playLineAudio(line)" title="播放" class="text-slate-400 hover:text-green-600 p-2">
                                        <svg v-if="isAuditioningId === line.id" class="h-4 w-4 animate-pulse text-green-600" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                                        <svg v-else class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg>
                                    </button>
                                    <button @click="removeScriptLine(index)" title="删除" class="text-slate-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity p-2">
                                        <svg class="h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                        </div>

                        <!-- 音效管理条 -->
                        <div class="flex flex-wrap items-center gap-2 w-full">
                            <div v-for="(sfx, sIdx) in line.sfx" :key="sIdx" class="flex items-center bg-blue-50 border border-blue-100 rounded px-2 py-1 text-xs">
                                <span class="mr-1"></span>
                                <select v-model="sfx.name" class="bg-transparent outline-none border-b border-transparent hover:border-blue-300 text-blue-700 font-medium max-w-[100px] cursor-pointer">
                                    <option v-for="libSfx in sfxLibrary" :key="libSfx.id" :value="libSfx.name">{{ libSfx.name }}</option>
                                </select>
                                <span class="mx-1 text-slate-400">@</span>
                                <input type="number" v-model="sfx.position" step="0.1" min="0" max="1" class="w-10 bg-transparent text-center outline-none border-b border-transparent hover:border-blue-300" title="插入位置 (0.0 - 1.0)">
                                <button @click="removeLineSfx(line, sIdx)" class="ml-2 text-slate-400 hover:text-red-500 font-bold">×</button>
                            </div>
                            <button @click="addLineSfx(line)" class="text-[10px] text-slate-400 hover:text-blue-600 border border-dashed border-slate-300 rounded px-2 py-1 hover:border-blue-400 transition-colors flex items-center gap-1">+ 音效</button>
                        </div>

                        <!-- 文本与音效区域 -->
                        <div class="w-full flex flex-col gap-2 min-w-0">
                            <textarea v-model="line.text" rows="2" class="w-full h-full bg-transparent border-none focus:ring-0 text-sm text-slate-700 resize-none leading-relaxed py-1.5" @input="autoResizeTextarea($event)"></textarea>
                        </div>
                    </div>
                    </div>
                </div>
            </div>

            <!-- 调试：显示原始 JSON -->
            <div v-if="rawAnalysisResult" class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm">
                <h3 class="text-sm font-bold text-slate-700 mb-2">3. AI 原始输出 (调试用)</h3>
                <pre class="bg-slate-800 text-slate-200 p-4 rounded-lg text-xs overflow-x-auto whitespace-pre-wrap max-h-64">{{ rawAnalysisResult }}</pre>
            </div>
            </div>
        </div>

        <!-- 页面 7: Prompt 管理 -->
        <div v-if="activeTab === 'prompt'" class="space-y-6">
            <div class="bg-slate-50 p-5 rounded-xl border border-slate-200">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-bold text-slate-700">自定义 Prompt 模板</h3>
                    <div class="space-x-2">
                        <button @click="savePrompt" class="px-4 py-2 bg-blue-600 text-white rounded-lg text-xs font-bold hover:bg-blue-700 transition-all">保存设置</button>
                        <button @click="resetPrompt" class="px-4 py-2 bg-slate-200 text-slate-600 rounded-lg text-xs font-bold hover:bg-slate-300 transition-all">恢复默认</button>
                    </div>
                </div>
                
                <div class="flex items-center gap-2 mb-4 bg-white p-3 rounded-lg border border-slate-200">
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" v-model="useCustomPrompt" class="sr-only peer">
                        <div class="w-11 h-6 bg-slate-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        <span class="ml-3 text-sm font-bold text-slate-700">启用自定义 Prompt</span>
                    </label>
                    <span class="text-xs text-slate-400 ml-2">(关闭时将使用系统内置的默认 Prompt)</span>
                </div>

                <textarea v-model="customPromptTemplate" :disabled="!useCustomPrompt" :class="['w-full h-[60vh] p-3 text-xs font-mono border rounded-lg focus:ring-2 focus:ring-blue-500 outline-none mb-3', !useCustomPrompt ? 'bg-slate-100 text-slate-400' : 'bg-white text-slate-700']" spellcheck="false"></textarea>
                <div class="mt-2 text-xs text-slate-500">
                    <span class="font-bold">可用变量:</span> ${emotionIntensity}, ${sfxSection}, ${bgmSection}, ${bgmExampleLine}, ${sfxExample}, ${rawScript}
                </div>
            </div>
        </div>

        <p style="text-align: left; color: #888; font-size: 12px;">
            <a href="https://space.bilibili.com/11354448" target="_blank" style="color: inherit; text-decoration: none;">
                本网站由sdsds222制作，点击此处访问个人主页
            </a>
        </p>

    </div>

    <script>
        const { createApp, ref, onMounted, computed, watch } = Vue;

        createApp({
            setup() {
                // --- IndexedDB Persistence Logic ---
                const DB_NAME = 'UnitaleDB';
                const DB_VERSION = 1;
                let dbInstance = null;
                let dbPromise = null;

                const initDB = () => {
                    if (dbInstance) return Promise.resolve(dbInstance);
                    if (dbPromise) return dbPromise;

                    dbPromise = new Promise((resolve, reject) => {
                        const request = indexedDB.open(DB_NAME, DB_VERSION);
                        request.onerror = (e) => { 
                            console.error('DB Error', e); 
                            dbPromise = null;
                            reject(e); 
                        };
                        request.onsuccess = (e) => {
                            dbInstance = e.target.result;
                            dbInstance.onclose = () => { dbInstance = null; dbPromise = null; };
                            dbInstance.onversionchange = () => { dbInstance.close(); dbInstance = null; dbPromise = null; };
                            resolve(dbInstance);
                        };
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains('project')) db.createObjectStore('project');
                            if (!db.objectStoreNames.contains('assets')) db.createObjectStore('assets');
                        };
                    });
                    return dbPromise;
                };

                const saveAssetToDB = async (key, blob) => {
                    try {
                        if (!dbInstance) await initDB();
                        return await new Promise((resolve, reject) => {
                            try {
                                const tx = dbInstance.transaction('assets', 'readwrite');
                                tx.objectStore('assets').put(blob, key);
                                tx.oncomplete = () => resolve();
                                tx.onerror = (e) => reject(e);
                            } catch (e) { reject(e); }
                        });
                    } catch (e) {
                        if (e.name === 'InvalidStateError' || (e.message && e.message.includes('closing'))) {
                            console.warn('DB connection closed, retrying saveAssetToDB...');
                            dbInstance = null;
                            dbPromise = null;
                            await initDB();
                            return new Promise((resolve, reject) => {
                                const tx = dbInstance.transaction('assets', 'readwrite');
                                tx.objectStore('assets').put(blob, key);
                                tx.oncomplete = () => resolve();
                                tx.onerror = (e) => reject(e);
                            });
                        }
                        throw e;
                    }
                };

                const loadAssetFromDB = async (key) => {
                    if (!dbInstance) await initDB();
                    return new Promise((resolve) => {
                        const tx = dbInstance.transaction('assets', 'readonly');
                        const req = tx.objectStore('assets').get(key);
                        req.onsuccess = () => resolve(req.result);
                        req.onerror = () => resolve(null);
                    });
                };

                const saveAssetsBatch = async (items) => {
                    if (!dbInstance) await initDB();
                    
                    // 1. 去重
                    const uniqueMap = new Map();
                    items.forEach(item => uniqueMap.set(item.key, item.blob));
                    const entries = Array.from(uniqueMap.entries());
                    
                    // 2. 分块保存 (Chunking) - 关键修复：避免一次性事务过大导致崩溃
                    const BATCH_SIZE = 5; 
                    
                    for (let i = 0; i < entries.length; i += BATCH_SIZE) {
                        const chunk = entries.slice(i, i + BATCH_SIZE);
                        
                        // 为每个块添加重试机制
                        let retries = 3;
                        while (retries > 0) {
                            try {
                                await new Promise((resolve, reject) => {
                                    const tx = dbInstance.transaction('assets', 'readwrite');
                                    const store = tx.objectStore('assets');
                                    tx.oncomplete = () => resolve();
                                    tx.onerror = (e) => reject(e);
                                    tx.onabort = (e) => reject(e);
                                    
                                    for (const [key, blob] of chunk) {
                                        store.put(blob, key);
                                    }
                                });
                                break; // 成功则跳出重试循环
                            } catch (e) {
                                console.warn(`Batch save failed (chunk ${i}), retrying...`, e);
                                retries--;
                                if (retries === 0) throw e; // 重试耗尽，抛出错误
                                // 尝试重置连接
                                dbInstance = null;
                                dbPromise = null;
                                await initDB();
                            }
                        }
                    }
                };

                const saveProjectToDB = async () => {
                    if (!dbInstance) await initDB();
                    
                    // Prepare data (exclude blobs from JSON, they are in assets store)
                    // 使用 JSON 序列化深拷贝，去除 Vue 的 Proxy 代理对象，防止 IndexedDB 报错 DataCloneError
                    const plainScriptLines = scriptLines.value.map(l => {
                        // Don't save audioUrl (blob url), just the ID implies existence of line_audio_{id}
                        const { audioUrl, isGenerating, ...rest } = l;
                        return rest;
                    });

                    const projectData = JSON.parse(JSON.stringify({
                        rawScript: rawScript.value,
                        rawAnalysisResult: rawAnalysisResult.value,
                        emotionIntensity: emotionIntensity.value,
                        characters: characters.value,
                        scriptLines: plainScriptLines,
                        libraries: {
                            sfx: sfxLibrary.value,
                            bgm: bgmLibrary.value,
                            timbres: timbres.value,
                            filters: filterLibrary.value,
                            emotions: emotionPresets.value
                        },
                        timestamp: Date.now()
                    }));

                    return new Promise((resolve, reject) => {
                        const tx = dbInstance.transaction('project', 'readwrite');
                        tx.objectStore('project').put(projectData, 'currentState');
                        tx.oncomplete = () => resolve();
                        tx.onerror = (e) => reject(e);
                    });
                };

                let saveTimeout = null;
                const triggerAutoSave = () => {
                    if (saveTimeout) clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                        saveProjectToDB().catch(e => console.warn('Auto-save failed', e));
                    }, 1000);
                };

                // 状态
                const activeTab = ref('script');
                
                watch(activeTab, (newValue) => {
                    localStorage.setItem('storyforge_activeTab', newValue);
                });
                const llmConfigs = ref([]);
                const currentConfigId = ref('');
                
                // 表单状态
                const form = ref({ id: '', name: '', baseUrl: '', model: '', key: '', params: '' });
                const isEditing = ref(false);

                // TTS 配置状态
                const ttsConfigs = ref([]);
                const ttsForm = ref({ id: '', name: '', baseUrl: '' });
                const isEditingTts = ref(false);

                // 角色库状态
                const characters = ref([]);

                // 音色库状态
                const timbres = ref([]);
                const timbreForm = ref({ id: '', name: '', description: '', refPath: '' });
                const isEditingTimbre = ref(false);
                const selectedTimbreId = ref('');
                const timbreFile = ref(null); // ADDED: To store the selected timbre file object

                // 情绪预设状态
                const emotionPresets = ref([]);
                const emotionForm = ref({ id: '', name: '', text: '' });
                const isEditingEmotion = ref(false);

                // 音效库状态
                const sfxLibrary = ref([]);
                const sfxForm = ref({ id: '', name: '', description: '', filename: '' });
                const isEditingSfx = ref(false);

                // BGM库状态
                const bgmLibrary = ref([]);
                const bgmForm = ref({ id: '', name: '', description: '', filename: '' });
                const isEditingBgm = ref(false);

                // 滤波器库状态
                const filterLibrary = ref([]);
                const filterForm = ref({ id: '', name: '', description: '', type: 'lowpass', frequency: 1000, Q: 1, gain: 0 });
                const isEditingFilter = ref(false);

                // 聊天状态
                const prompt = ref('');
                const result = ref('');
                const reasoning = ref('');
                const error = ref('');
                const loading = ref(false);
                const abortController = ref(null);

                // TTS 状态
                const currentTtsConfigId = ref('');
                const ttsRefFile = ref(null);
                const ttsRefPath = ref('uploaded/ref.wav'); // 默认路径示例
                const ttsEmoText = ref('中立');
                const audioUrl = ref('');
                const ttsLoading = ref(false);
                const ttsError = ref('');
                const ttsAbortController = ref(null);

                // 脚本制作状态
                const rawScript = ref('');
                const scriptLines = ref([]);
                const isAnalyzingScript = ref(false);
                const rawAnalysisResult = ref('');
                const emotionIntensity = ref(5);
                const selectedLineIndex = ref(-1);
                const isGeneratingAll = ref(false);
                const isSequencePlaying = ref(false);
                const currentSequenceIndex = ref(-1);
                let sequenceAbortController = null;
                const isExportingAudio = ref(false);
                const importFileRef = ref(null);
                const isExportingProject = ref(false);
                const exportStatus = ref('');
                let bgmAudioNode = null;
                let bgmGainNode = null;
                const playbackProgress = ref(0);
                let playbackAnimationFrame = null;

                // 剪辑拖拽状态
                const draggingTrimState = ref(null);

                // 计算当前选中的配置
                const currentConfig = computed(() => {
                    return llmConfigs.value.find(c => c.id === currentConfigId.value) || null;
                });

                // Prompt Template
                const defaultPromptTemplate = `你的任务是将给定小说内容拆分为台词和旁白，并自动识别每一句台词的角色和情绪。
**注意：生成的结果将直接用于 IndexTTS 语音合成系统，请确保情绪描述精准且符合语音合成的提示规范。**

# 全局设置
- **感情强度等级**: \${emotionIntensity} / 10
  - 请根据此强度调整 \`emotion_text\` 的用词力度。
  - 强度较低时(1-3)：必须极其克制，接近中性。多使用“平淡”、“冷静”、“毫无波澜”、“客观”等词汇。除非原文有极强的爆发，否则一律处理为微弱情绪。
  - 强度适中时(4-7)：情绪自然流露，但不要过分夸张（如：有些生气、开心、疑惑）。
  - 强度较高时(8-10)：情绪强烈、饱满、极具张力（如：歇斯底里地咆哮、极度狂喜、痛哭流涕）。

\${sfxSection}

\${bgmSection}

\${filterSection}

# 规则

## 1. 拆分与识别
- **完整保留**: 必须完整保留原文内容，不得遗漏、删改或省略任何字句。
- **内容提取**: 提取对话内容和所有非对话的旁白。
- **角色识别**: 根据小说内容分析说话人。旁白的角色名统一标记为“旁白”。

## 2. 情绪识别 (emotion_text)
- **情绪描述**: 根据上下文语境，为每条内容生成一段简短的情绪描述文本。
    - 格式: 字符串。
    - **长度限制**: **必须非常简短，严格控制在 2-6 个字以内**。
    - **用词规范**: **所有情绪描述必须克制、微弱、内敛**。即使是强烈的情绪，也请用“微”、“略”、“淡淡”等词修饰，避免过于夸张。
    - 内容: 描述说话人的语气、情感状态。例如：“略显生气”、“淡淡忧伤”、“冷静”、“微弱惊讶”。
    - 旁白情绪: **强制规则**：如果角色是“旁白”，\`emotion_text\` **必须** 填写为 “中立”。**绝对禁止** 为旁白添加任何其他情绪描述（如“悲伤”、“紧张”等）。旁白必须是完全客观、冷静的叙述。

## 3. 音效插入 (sfx)
- 如果情节需要（如“摔门而去”、“雷声大作”），且音效库中有对应素材，请在 JSON 对象中添加 \`sfx\` 字段。
- **严格限制**: 只能使用【音效库】中列出的名称。如果库为空或没有匹配项，**绝对不要**添加此字段。
- **支持多音效**: 一句台词中可以插入多个音效，只要位置合理（如开头关门，中间脚步声）。
- 格式: \`"sfx": [{"name": "音效名称", "position": 0.5}, {"name": "另一音效", "position": 0.9}]\`
- \`position\`: 0.0-1.0 之间的浮点数，表示音效在**台词念白时长内**的插入位置（例如 0.0 为开始，1.0 为念白结束）。
- **重要**: \`position\` 计算**不包含** \`break_duration\`（停顿时间）。即 1.0 代表台词说完的那一刻，而不是停顿结束的那一刻。
- **间隔音效**: 如果音效发生在台词后的停顿期间，请将其加入该台词的 \`sfx\` 列表，位置设为 1.0。

## 4. 背景音乐控制 (BGM Control)
- **开头BGM**: 请**务必**在脚本的最开始尝试匹配并插入一个适合当前氛围的 BGM。只要【背景音乐库】中有合适的，就**必须**插入。
- 当剧情氛围发生变化，需要切换或停止背景音乐时，请插入一个独立的 BGM 控制对象。
- **格式**: \`{"type": "bgm", "action": "play", "name": "BGM名称"}\` 或 \`{"type": "bgm", "action": "stop"}\`
- **严格限制**:
  - \`name\` 字段**必须完全等于**【背景音乐库】中列出的某一个名称。
  - 如果【背景音乐库】为空，或者没有匹配的音乐，**绝对不要**生成 action="play" 的控制块。
  - 禁止使用 "MysteriousBGM", "SadPiano" 等示例中出现但库里没有的名称。
- **注意**: 不要将 bgm 字段放在台词对象中。

- **停顿时间**: 分析台词后的剧情节奏，设置该台词结束后的停顿时间（秒）。
- 默认为 0。如果有动作描写或心理活动暗示停顿，请设置相应时长（如 0.5, 1.0, 2.0）。
- 示例: 两人对话间的尴尬沉默，或动作描写（如“他喝了一口茶”）需要的时间。

## 5. 音频滤波器 (Filter)
- 如果剧情环境特殊（如“在水下说话”、“电话通话中”、“回忆/内心独白”），且【滤波器库】中有对应效果，请在台词对象中添加 \`filter\` 字段。
- **格式**: \`"filter": "滤波器名称"\`
- **严格限制**: 必须使用【滤波器库】中存在的名称。如果没有匹配项，**不要**生成此字段。
- **特别提醒**: 如果角色是“旁白”，**千万不要**使用滤波器功能。

## 6. 输出格式
- **严格 JSON**: 输出格式必须是严格的 JSON 数组，不包含任何额外说明或代码块标记。
- **数组元素**: 必须是以下两种对象之一：
  1. **台词对象**: \`{"type": "dialogue", "role_name": "...", "text_content": "...", "emotion_text": "...", "break_duration": 0, "filter": "...", "sfx": [...]}\`
  2. **BGM对象**: \`{"type": "bgm", "action": "play", "name": "..."}\` 或 \`{"type": "bgm", "action": "stop"}\`
  - **严禁生成** \`{"type": "sfx", ...}\` 这种独立音效块。音效必须包含在台词对象的 \`sfx\` 字段中。


## 小说原文:
<novel_content>
“别接那个电话！”老李猛地按住了我的手，脸色惨白，“那是昨晚值班的小张打来的。”
我愣住了，看着办公桌上疯狂震动的座机：“可是……小张不是今早已经确认死亡了吗？”
“对，”老李的声音在发抖，“所以，别接。如果你接了，他会问你为什么不救他。”
</novel_content>

## 输出:
[
\${bgmExampleLine}
  {"type": "dialogue", "role_name": "老李", "text_content": "别接那个电话！那是昨晚值班的小张打来的。", "emotion_text": "紧张，急切", "break_duration": 0.5},
  {"type": "dialogue", "role_name": "旁白", "text_content": "老李猛地按住了我的手，脸色惨白。我愣住了，看着办公桌上疯狂震动的座机。", "emotion_text": "中立", "break_duration": 0.5\${sfxExample}},
  {"type": "dialogue", "role_name": "我", "text_content": "可是……小张不是今早已经确认死亡了吗？", "emotion_text": "疑惑，迟疑", "break_duration": 0.5},
  {"type": "dialogue", "role_name": "老李", "text_content": "对，所以，别接。如果你接了，他会问你为什么不救他。", "emotion_text": "低沉，压抑", "break_duration": 0}
]

# 输入内容

## 小说原文:
<novel_content>
\${rawScript}
</novel_content>`;

                const customPromptTemplate = ref(defaultPromptTemplate);
                const useCustomPrompt = ref(false);

                // --- 音频引擎与缓存 (Audio Engine & Cache) ---
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBufferCache = new Map();
                const localFileMap = ref(new Map());

                const loadAudioBuffer = async (filename) => {
                    if (!filename) return null;
                    if (audioBufferCache.has(filename)) return audioBufferCache.get(filename);

                    try {
                        let arrayBuffer;
                        if (localFileMap.value.has(filename)) {
                            arrayBuffer = await localFileMap.value.get(filename).arrayBuffer();
                        } else if (filename.match(/^(https?:\/\/|blob:)/)) {
                            const res = await fetch(filename);
                            if (!res.ok) throw new Error(`Failed to fetch ${filename}`);
                            arrayBuffer = await res.arrayBuffer();
                        } else {
                            throw new Error(`Audio file not found in memory: ${filename}`);
                        }
                        const buffer = await audioContext.decodeAudioData(arrayBuffer);
                        audioBufferCache.set(filename, buffer);
                        return buffer;
                    } catch (e) {
                        console.warn(`Failed to load audio: ${filename}`, e);
                        return null;
                    }
                };

                // --- 预览播放逻辑 ---
                const previewPlayingFile = ref(null);
                let previewSource = null;

                const playPreview = async (filename) => {
                    if (audioContext.state === 'suspended') await audioContext.resume();
                    
                    if (previewSource) {
                        try { previewSource.stop(); } catch(e){}
                        previewSource = null;
                    }

                    if (previewPlayingFile.value === filename) {
                        previewPlayingFile.value = null;
                        return;
                    }

                    if (!filename) return;

                    const buffer = await loadAudioBuffer(filename);
                    if (buffer) {
                        previewSource = audioContext.createBufferSource();
                        previewSource.buffer = buffer;
                        previewSource.connect(audioContext.destination);
                        previewSource.onended = () => {
                            if (previewPlayingFile.value === filename) previewPlayingFile.value = null;
                        };
                        previewSource.start();
                        previewPlayingFile.value = filename;
                    }
                };

                const preloadAudioAssets = async () => {
                    // 移除启动时的自动预加载，因为现在没有持久化的文件列表
                    // 仅在导入工程后或添加文件时加载
                };

                // --- 波形绘制与剪辑逻辑 ---
                const drawWaveform = async (canvas, line) => {
                    if (!canvas || !line.audioUrl) return;
                    
                    // 性能优化：如果 URL 没变，且 Canvas 已经绘制过，则跳过重绘
                    if (canvas._lastUrl === line.audioUrl) return;
                    canvas._lastUrl = line.audioUrl;

                    const buffer = await loadAudioBuffer(line.audioUrl);
                    if (!buffer) return;

                    const ctx = canvas.getContext('2d');
                    const width = canvas.width;
                    const height = canvas.height;
                    const data = buffer.getChannelData(0);
                    const step = Math.ceil(data.length / width);
                    const amp = height / 2;

                    ctx.clearRect(0, 0, width, height);
                    ctx.fillStyle = '#94a3b8'; // slate-400
                    ctx.beginPath();
                    
                    for (let i = 0; i < width; i++) {
                        let min = 1.0;
                        let max = -1.0;
                        for (let j = 0; j < step; j++) {
                            const datum = data[(i * step) + j];
                            if (datum < min) min = datum;
                            if (datum > max) max = datum;
                        }
                        ctx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                    }
                };

                const startDragTrim = (e, line, type) => {
                    draggingTrimState.value = {
                        lineId: line.id,
                        type: type, // 'start' or 'end'
                        startX: e.clientX,
                        containerWidth: e.target.closest('.relative').offsetWidth,
                        startVal: type === 'start' ? (line.trimStart || 0) : (line.trimEnd || 1)
                    };
                    
                    const onMove = (ev) => {
                        if (!draggingTrimState.value) return;
                        const state = draggingTrimState.value;
                        const line = scriptLines.value.find(l => l.id === state.lineId);
                        if (!line) return;

                        const deltaX = ev.clientX - state.startX;
                        const deltaPercent = deltaX / state.containerWidth;
                        let newVal = Math.max(0, Math.min(1, state.startVal + deltaPercent));

                        if (state.type === 'start') {
                            line.trimStart = Math.min(newVal, (line.trimEnd || 1) - 0.01);
                        } else {
                            line.trimEnd = Math.max(newVal, (line.trimStart || 0) + 0.01);
                        }
                    };

                    const onUp = () => {
                        window.removeEventListener('mousemove', onMove);
                        window.removeEventListener('mouseup', onUp);
                        draggingTrimState.value = null;
                        triggerAutoSave(); // 保存剪辑结果
                    };

                    window.addEventListener('mousemove', onMove);
                    window.addEventListener('mouseup', onUp);
                };

                // Watchers for Auto-Save
                watch([rawScript, characters, sfxLibrary, bgmLibrary, timbres, filterLibrary, emotionPresets, emotionIntensity], () => {
                    triggerAutoSave();
                }, { deep: true });
                
                watch(scriptLines, () => {
                    triggerAutoSave();
                }, { deep: true });

                // 读取持久化配置
                onMounted(async () => {

                    // 仅保留 LLM 和 TTS 的配置持久化 (API Key 等)
                    const savedList = localStorage.getItem('storyforge_configs');
                    if (savedList) {
                        llmConfigs.value = JSON.parse(savedList);
                    } else {
                        // 迁移旧数据或初始化默认
                        const oldSingle = localStorage.getItem('storyforge_universal_v2');
                        if (oldSingle) {
                            const c = JSON.parse(oldSingle);
                            llmConfigs.value.push({ ...c, id: Date.now().toString(), name: '默认配置' });
                            localStorage.removeItem('storyforge_universal_v2');
                        }
                    }
                    
                    // 默认选中第一个
                    if (llmConfigs.value.length > 0) {
                        currentConfigId.value = llmConfigs.value[0].id;
                    }

                    // 读取 TTS 配置
                    const savedTts = localStorage.getItem('storyforge_tts_configs');
                    if (savedTts) ttsConfigs.value = JSON.parse(savedTts);
                    if (ttsConfigs.value.length > 0) currentTtsConfigId.value = ttsConfigs.value[0].id;
                    
                    // 初始化默认滤波器
                    filterLibrary.value = [
                        { id: 'f1', name: '电话音', description: '模拟电话通话时的窄频带声音', type: 'bandpass', frequency: 1700, Q: 1.5, gain: 0, enabled: true },
                        { id: 'f2', name: '水下', description: '模拟在水下听到的闷声', type: 'lowpass', frequency: 400, Q: 1, gain: 0, enabled: true },
                        { id: 'f3', name: '老广播', description: '模拟老式收音机或广播的尖锐声音', type: 'highpass', frequency: 1500, Q: 1, gain: 0, enabled: true },
                        { id: 'f4', name: '机械失真', description: '模拟机器人或设备损坏时的失真声音', type: 'distortion', frequency: 1000, Q: 1, gain: 50, enabled: true }
                    ];

                    // 初始化默认情绪
                    emotionPresets.value = [
                        { id: '1', name: '中立',    text: '语气平淡，客观冷静' },
                        { id: '2', name: '开心',      text: '嘴角微扬，略带笑意' },
                        { id: '3', name: '悲伤',        text: '声音低沉，略显失落' },
                        { id: '4', name: '愤怒',      text: '语气生硬，压抑怒火' },
                        { id: '5', name: '惊讶',  text: '略显意外，语调微扬' },
                        { id: '6', name: '恐惧',       text: '呼吸微促，略带不安' },
                        { id: '7', name: '厌恶',    text: '眉头微皱，略显不耐' },
                        { id: '8', name: '激动',    text: '语速稍快，略显急切' }
                    ];

                    const savedPrompt = localStorage.getItem('storyforge_prompt_template');
                    if (savedPrompt) {
                        customPromptTemplate.value = savedPrompt;
                    }

                    const savedUseCustom = localStorage.getItem('storyforge_use_custom_prompt');
                    if (savedUseCustom) {
                        useCustomPrompt.value = JSON.parse(savedUseCustom);
                    }

                    // --- Restore from IndexedDB ---
                    try {
                        if (!dbInstance) await initDB();
                        
                        // 1. Load Project Data
                        const projectData = await new Promise((resolve) => {
                            const tx = dbInstance.transaction('project', 'readonly');
                            const req = tx.objectStore('project').get('currentState');
                            req.onsuccess = () => resolve(req.result);
                            req.onerror = () => resolve(null);
                        });

                        if (projectData) {
                            rawScript.value = projectData.rawScript || '';
                            rawAnalysisResult.value = projectData.rawAnalysisResult || '';
                            emotionIntensity.value = projectData.emotionIntensity || 5;
                            characters.value = projectData.characters || [];
                            
                            if (projectData.libraries) {
                                sfxLibrary.value = projectData.libraries.sfx || [];
                                bgmLibrary.value = projectData.libraries.bgm || [];
                                timbres.value = projectData.libraries.timbres || [];
                                filterLibrary.value = projectData.libraries.filters || [];
                                emotionPresets.value = projectData.libraries.emotions || [];
                            }

                            // 2. Restore Assets & Audio
                            const restoreAssets = async (lib, fileKey) => {
                                for (const item of lib) {
                                    const filename = item[fileKey];
                                    if (filename) {
                                        const blob = await loadAssetFromDB(filename);
                                        if (blob) {
                                            const file = new File([blob], filename, { type: blob.type });
                                            localFileMap.value.set(filename, file);
                                            loadAudioBuffer(filename);
                                        }
                                    }
                                }
                            };
                            await restoreAssets(sfxLibrary.value, 'filename');
                            await restoreAssets(bgmLibrary.value, 'filename');
                            await restoreAssets(timbres.value, 'refPath');

                            // 3. Restore Script Lines
                            const restoredLines = [];
                            for (const lineData of projectData.scriptLines) {
                                // 确保 trimStart/trimEnd 存在
                                const line = { trimStart: 0, trimEnd: 1, ...lineData, audioUrl: '', isGenerating: false };
                                
                                if (line.type === 'dialogue') {
                                    const audioKey = `line_audio_${line.id}`;
                                    const blob = await loadAssetFromDB(audioKey);
                                    if (blob) {
                                        line.audioUrl = URL.createObjectURL(blob);
                                    }
                                }
                                restoredLines.push(line);
                            }
                            scriptLines.value = restoredLines;
                            console.log('Project state restored from IndexedDB');
                        }
                    } catch (e) {
                        console.error('Failed to restore from IndexedDB', e);
                    }
                });

                const currentTtsConfig = computed(() => {
                    return ttsConfigs.value.find(c => c.id === currentTtsConfigId.value) || null;
                });

                // --- 配置管理逻辑 ---
                const saveConfigsToLocal = () => {
                    localStorage.setItem('storyforge_configs', JSON.stringify(llmConfigs.value));
                };

                const saveConfig = () => {
                    if (!form.value.name || !form.value.baseUrl || !form.value.key) {
                        return alert('请填写完整信息');
                    }
                    
                    form.value.baseUrl = form.value.baseUrl.trim();
                    form.value.key = form.value.key.trim();

                    if (isEditing.value) {
                        const index = llmConfigs.value.findIndex(c => c.id === form.value.id);
                        if (index !== -1) llmConfigs.value[index] = { ...form.value };
                    } else {
                        llmConfigs.value.push({ ...form.value, id: Date.now().toString() });
                    }
                    
                    saveConfigsToLocal();
                    resetForm();
                    
                    // 如果是第一个，自动选中
                    if (llmConfigs.value.length === 1) {
                        currentConfigId.value = llmConfigs.value[0].id;
                    }
                };

                const editConfig = (conf) => {
                    form.value = { ...conf };
                    isEditing.value = true;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };

                const deleteConfig = (id) => {
                    if (!confirm('确定删除此配置吗？')) return;
                    llmConfigs.value = llmConfigs.value.filter(c => c.id !== id);
                    saveConfigsToLocal();
                    if (currentConfigId.value === id) currentConfigId.value = '';
                };

                const resetForm = () => {
                    form.value = { id: '', name: '', baseUrl: '', model: '', key: '', params: '' };
                    isEditing.value = false;
                };

                // --- TTS 配置管理逻辑 ---
                const saveTtsConfigsToLocal = () => {
                    localStorage.setItem('storyforge_tts_configs', JSON.stringify(ttsConfigs.value));
                };

                const saveTtsConfig = () => {
                    if (!ttsForm.value.name || !ttsForm.value.baseUrl) {
                        return alert('请填写完整信息');
                    }
                    
                    ttsForm.value.baseUrl = ttsForm.value.baseUrl.trim();

                    if (isEditingTts.value) {
                        const index = ttsConfigs.value.findIndex(c => c.id === ttsForm.value.id);
                        if (index !== -1) ttsConfigs.value[index] = { ...ttsForm.value };
                    } else {
                        ttsConfigs.value.push({ ...ttsForm.value, id: Date.now().toString() });
                    }
                    
                    saveTtsConfigsToLocal();
                    resetTtsForm();
                };

                const editTtsConfig = (conf) => {
                    ttsForm.value = { ...conf };
                    isEditingTts.value = true;
                };

                const deleteTtsConfig = (id) => {
                    if (!confirm('确定删除此 TTS 配置吗？')) return;
                    ttsConfigs.value = ttsConfigs.value.filter(c => c.id !== id);
                    saveTtsConfigsToLocal();
                };

                const resetTtsForm = () => {
                    ttsForm.value = { id: '', name: '', baseUrl: '' };
                    isEditingTts.value = false;
                };

                // --- 角色库管理逻辑 (左侧栏) ---
                const addCharacter = () => {
                    characters.value.push({ 
                        id: Date.now().toString(), 
                        name: '新角色', 
                        voiceFile: '' // Path for both display and synthesis
                    });
                };

                const deleteCharacter = (id) => {
                    if (!confirm('确定删除此角色吗？')) return;
                    characters.value = characters.value.filter(c => c.id !== id);
                };



                const handleTimbreFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        timbreForm.value.refPath = file.name;
                        timbreFile.value = file; // Store the file object
                        localFileMap.value.set(file.name, file);
                        saveAssetToDB(file.name, file); // Save to DB
                        triggerAutoSave();
                    }
                    event.target.value = ''; // Reset file input
                };

                // --- 音色库管理逻辑 ---
                const syncTimbresWithServer = async () => {
                    // 尝试获取可用的 TTS 配置
                    let cfg = currentTtsConfig.value;
                    if (!cfg && ttsConfigs.value.length > 0) {
                        // 如果当前未选中，默认使用第一个
                        currentTtsConfigId.value = ttsConfigs.value[0].id;
                        cfg = ttsConfigs.value[0];
                    }
                    
                    if (!cfg) {
                        console.warn("未找到可用的 TTS 配置，无法同步音色文件。");
                        return;
                    }

                    const baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                    console.log(`正在同步音色文件到服务器: ${baseUrl}`);

                    for (const t of timbres.value) {
                        if (!t.refPath) continue;
                        
                        // 检查内存中是否有该文件
                        const file = localFileMap.value.get(t.refPath);
                        if (!file) {
                            console.warn(`音色文件未在内存中找到 (可能未导入或丢失): ${t.refPath}`);
                            continue;
                        }

                        try {
                            // 1. 检查服务器是否存在
                            const checkUrl = `${baseUrl}/v1/check/audio?file_name=${encodeURIComponent(t.refPath)}`;
                            const checkRes = await fetch(checkUrl);
                            let exists = false;
                            if (checkRes.ok) {
                                const checkData = await checkRes.json();
                                exists = checkData.exists;
                            }

                            // 2. 如果不存在，则上传
                            if (!exists) {
                                console.log(`正在上传缺失的音色文件: ${t.name} (${t.refPath})`);
                                const formData = new FormData();
                                formData.append('audio', file);
                                formData.append('full_path', t.refPath);

                                await fetch(`${baseUrl}/v1/upload_audio`, {
                                    method: 'POST',
                                    body: formData,
                                });
                            } else {
                                console.log(`音色文件已存在: ${t.name}`);
                            }
                        } catch(e) {
                            console.error(`同步音色 ${t.name} 失败:`, e);
                        }
                    }
                    console.log("音色同步完成。");
                };

                const saveTimbre = async () => {
                    if (!timbreForm.value.name || !timbreForm.value.refPath) {
                        return alert('请填写音色名称并选择一个参考音频文件');
                    }
                    if (!currentTtsConfig.value) {
                        return alert('请选择一个有效的 TTS 服务以上传音频。');
                    }

                    // A file MUST be selected when creating a NEW timbre.
                    if (!isEditingTimbre.value && !timbreFile.value) {
                        return alert('创建新音色时，必须选择一个参考音频文件。');
                    }

                    const filename = timbreForm.value.refPath;
                    const serverPath = filename; 
                    
                    // 确定 ID (如果是新建，提前生成 ID 以便保存文件到本地存储)
                    let targetId = timbreForm.value.id;
                    if (!targetId) {
                        targetId = Date.now().toString();
                    }

                    try {
                        // We only perform an upload if a file was actually selected via the file input.
                        if (timbreFile.value) {
                            const cfg = currentTtsConfig.value;
                            const baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');
                            
                            const formData = new FormData();
                            formData.append('audio', timbreFile.value, filename);
                            formData.append('full_path', serverPath);

                            const uploadRes = await fetch(`${baseUrl}/v1/upload_audio`, {
                                method: 'POST',
                                body: formData,
                            });
                            
                            if (!uploadRes.ok) {
                                 const errorText = await uploadRes.text();
                                 throw new Error(`上传参考音频到 TTS 服务器失败: ${errorText}`);
                            }
                             console.log(`音色文件 '${filename}' 已成功上传到 TTS 服务器。`);
                        }

                        const newTimbreData = { ...timbreForm.value, id: targetId };

                        // After a potential upload, save the metadata.
                        if (isEditingTimbre.value) {
                            const index = timbres.value.findIndex(c => c.id === targetId);
                            if (index !== -1) {
                                timbres.value[index] = newTimbreData;
                            }
                        } else {
                            timbres.value.push(newTimbreData);
                        }
                        // saveTimbresToLocal(); // 不再持久化到 localStorage
                        resetTimbreForm();

                    } catch(e) {
                        console.error("保存音色时出错:", e);
                        alert(`保存音色失败: ${e.message}`);
                    }
                };

                const editTimbre = (timbre) => {
                    timbreForm.value = { ...timbre };
                    isEditingTimbre.value = true;
                    timbreFile.value = null; // Important: reset file on edit start
                };

                const deleteTimbre = async (id) => {
                    if (!confirm('确定删除此音色吗？')) return;
                    timbres.value = timbres.value.filter(c => c.id !== id);
                    // saveTimbresToLocal();
                    if (selectedTimbreId.value === id) selectedTimbreId.value = '';
                };

                const resetTimbreForm = () => {
                    timbreForm.value = { id: '', name: '', description: '', refPath: '' };
                    isEditingTimbre.value = false;
                    timbreFile.value = null; // Reset the stored file
                };

                // --- 音效库管理逻辑 ---
                // 移除 saveSfxToLocal

                const saveSfx = async () => {
                    if (!sfxForm.value.name || !sfxForm.value.filename) {
                        return alert('请填写音效名称和文件路径');
                    }
                    
                    try {
                        if (isEditingSfx.value) {
                            const index = sfxLibrary.value.findIndex(s => s.id === sfxForm.value.id);
                            if (index !== -1) sfxLibrary.value[index] = { ...sfxForm.value };
                        } else {
                            sfxLibrary.value.push({ ...sfxForm.value, id: Date.now().toString(), enabled: true });
                        }
                        if (sfxForm.value.filename) loadAudioBuffer(sfxForm.value.filename);
                        // saveSfxToLocal();
                        resetSfxForm();
                    } catch (e) {
                        alert(`保存音效失败: ${e.message}`);
                    }
                };

                const editSfx = (sfx) => {
                    sfxForm.value = { ...sfx };
                    isEditingSfx.value = true;
                };

                const deleteSfx = (id) => {
                    if (!confirm('确定删除？')) return;
                    sfxLibrary.value = sfxLibrary.value.filter(s => s.id !== id);
                    // saveSfxToLocal();
                };

                const resetSfxForm = () => {
                    sfxForm.value = { id: '', name: '', description: '', filename: '' };
                    isEditingSfx.value = false;
                };

                const handleSfxFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        sfxForm.value.filename = file.name;
                        localFileMap.value.set(file.name, file);
                        saveAssetToDB(file.name, file); // Save to DB
                        triggerAutoSave();
                        loadAudioBuffer(file.name);
                    }
                event.target.value = '';
                };

                // --- BGM库管理逻辑 ---
                const saveBgmToLocal = () => {
                    localStorage.setItem('storyforge_bgm', JSON.stringify(bgmLibrary.value));
                };

                const saveBgm = async () => {
                    if (!bgmForm.value.name || !bgmForm.value.filename) {
                        return alert('请填写 BGM 名称和文件路径');
                    }
                    
                    try {
                        if (isEditingBgm.value) {
                            const index = bgmLibrary.value.findIndex(s => s.id === bgmForm.value.id);
                            if (index !== -1) bgmLibrary.value[index] = { ...bgmForm.value };
                        } else {
                            bgmLibrary.value.push({ ...bgmForm.value, id: Date.now().toString(), enabled: true });
                        }
                        if (bgmForm.value.filename) loadAudioBuffer(bgmForm.value.filename);
                        // saveBgmToLocal();
                        resetBgmForm();
                    } catch (e) {
                        alert(`保存 BGM 失败: ${e.message}`);
                    }
                };

                const editBgm = (bgm) => {
                    bgmForm.value = { ...bgm };
                    isEditingBgm.value = true;
                };

                const deleteBgm = (id) => {
                    if (!confirm('确定删除？')) return;
                    bgmLibrary.value = bgmLibrary.value.filter(s => s.id !== id);
                    // saveBgmToLocal();
                };

                const resetBgmForm = () => {
                    bgmForm.value = { id: '', name: '', description: '', filename: '' };
                    isEditingBgm.value = false;
                };

                const handleBgmFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        bgmForm.value.filename = file.name;
                        localFileMap.value.set(file.name, file);
                        saveAssetToDB(file.name, file); // Save to DB
                        triggerAutoSave();
                        loadAudioBuffer(file.name);
                    }
                    event.target.value = '';
                };

                // --- 滤波器库管理逻辑 ---
                const saveFiltersToLocal = () => {
                    localStorage.setItem('storyforge_filters', JSON.stringify(filterLibrary.value));
                };

                const saveFilter = () => {
                    if (!filterForm.value.name) return alert('请填写滤波器名称');
                    
                    const newFilter = { ...filterForm.value };
                    // Ensure numbers
                    newFilter.frequency = Number(newFilter.frequency);
                    newFilter.Q = Number(newFilter.Q);
                    newFilter.gain = Number(newFilter.gain);

                    if (isEditingFilter.value) {
                        const index = filterLibrary.value.findIndex(f => f.id === filterForm.value.id);
                        if (index !== -1) filterLibrary.value[index] = newFilter;
                    } else {
                        filterLibrary.value.push({ ...newFilter, id: Date.now().toString(), enabled: true });
                    }
                    // saveFiltersToLocal();
                    resetFilterForm();
                };

                const editFilter = (filter) => {
                    filterForm.value = { ...filter };
                    isEditingFilter.value = true;
                };

                const deleteFilter = (id) => {
                    if (!confirm('确定删除此滤波器？')) return;
                    filterLibrary.value = filterLibrary.value.filter(f => f.id !== id);
                    // saveFiltersToLocal();
                };

                const resetFilterForm = () => {
                    filterForm.value = { id: '', name: '', description: '', type: 'lowpass', frequency: 1000, Q: 1, gain: 0 };
                    isEditingFilter.value = false;
                };

                // --- 情绪预设管理逻辑 ---
                // 移除 saveEmotionPresetsToLocal

                const saveEmotion = () => {
                    if (!emotionForm.value.name || !emotionForm.value.text) return alert('请填写完整');
                    if (isEditingEmotion.value) {
                        const index = emotionPresets.value.findIndex(e => e.id === emotionForm.value.id);
                        if (index !== -1) emotionPresets.value[index] = { ...emotionForm.value };
                    } else {
                        emotionPresets.value.push({ ...emotionForm.value, id: Date.now().toString() });
                    }
                    // saveEmotionPresetsToLocal();
                    resetEmotionForm();
                };

                const editEmotion = (emo) => {
                    emotionForm.value = { ...emo };
                    isEditingEmotion.value = true;
                };

                const deleteEmotion = (id) => {
                    if (!confirm('确定删除？')) return;
                    emotionPresets.value = emotionPresets.value.filter(e => e.id !== id);
                    // saveEmotionPresetsToLocal();
                };

                const resetEmotionForm = () => {
                    emotionForm.value = { id: '', name: '', text: '' };
                    isEditingEmotion.value = false;
                };

                const getPresetId = (text) => {
                    const found = emotionPresets.value.find(p => p.text === text);
                    return found ? found.id : 'custom';
                };

                const getEmotionSelectValue = (line) => {
                    if (line.emotion_text === line.original_emotion_text) return "";
                    const preset = emotionPresets.value.find(p => p.text === line.emotion_text);
                    return preset ? preset.text : "custom_option";
                };

                const applyPresetToLine = (line, event) => {
                    const presetText = event.target.value;
                    if (presetText === 'custom_option') return;

                    if (presetText) {
                        line.emotion_text = presetText;
                    } else {
                        line.emotion_text = line.original_emotion_text || '中立';
                    }
                };

                const resetEmotionsToDefault = () => {
                    if (!confirm('确定要重置所有情绪预设为默认值吗？这将清除自定义的情绪。')) return;
                    emotionPresets.value = [
                        { id: '1', name: '中立',    text: '语气平淡，客观冷静' },
                        { id: '2', name: '开心',      text: '嘴角微扬，略带笑意' },
                        { id: '3', name: '悲伤',        text: '声音低沉，略显失落' },
                        { id: '4', name: '愤怒',      text: '语气生硬，压抑怒火' },
                        { id: '5', name: '惊讶',  text: '略显意外，语调微扬' },
                        { id: '6', name: '恐惧',       text: '呼吸微促，略带不安' },
                        { id: '7', name: '厌恶',    text: '眉头微皱，略显不耐' },
                        { id: '8', name: '激动',    text: '语速稍快，略显急切' }
                    ];
                    // saveEmotionPresetsToLocal();
                };

                const availableRoles = computed(() => {
                    const roles = new Set(characters.value.map(c => c.name));
                    return Array.from(roles);
                });

                // --- 拖拽与排序逻辑 ---
                const draggingIndex = ref(-1);
                const moveLineUp = (index) => {
                    if (index <= 0) return;
                    const item = scriptLines.value.splice(index, 1)[0];
                    scriptLines.value.splice(index - 1, 0, item);
                };
                const moveLineDown = (index) => {
                    if (index >= scriptLines.value.length - 1) return;
                    const item = scriptLines.value.splice(index, 1)[0];
                    scriptLines.value.splice(index + 1, 0, item);
                };

                let dialogueSource = null;
                let sfxSources = [];
                const isAuditioningId = ref(null);

                // Helper for distortion
                const makeDistortionCurve = (amount) => {
                    const k = typeof amount === 'number' ? amount : 50;
                    const n_samples = 44100;
                    const curve = new Float32Array(n_samples);
                    const deg = Math.PI / 180;
                    for (let i = 0; i < n_samples; ++i) {
                        const x = (i * 2) / n_samples - 1;
                        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                    }
                    return curve;
                };

                const generateLineAudio = async (line) => {
                    if (!currentTtsConfig.value) return alert('请先在 TTS 配置中心选择一个 TTS 服务');
                    
                    line.isGenerating = true;

                    try {
                        const char = characters.value.find(c => c.name === line.role);
                        // Use char.voiceFile and check if it's a non-empty string
                        if (!char || !char.voiceFile) {
                            throw new Error(`角色 "${line.role}" 未绑定音色文件路径。\n\n请在左侧的角色列表中为该角色选择一个音色文件，或手动输入路径。`);
                        }
                        
                        const payload = {
                            text: line.text,
                            audio_path: char.voiceFile, // Use voiceFile directly
                            emo_text: line.emotion_text || '中立',
                        };

                        const cfg = currentTtsConfig.value;
                        const baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');

                        // --- 自动上传逻辑 (Lazy Upload) ---
                        // 检查本地是否有该音色文件，如果有，则检查服务器是否存在，不存在则上传
                        const voiceFile = localFileMap.value.get(char.voiceFile);
                        if (voiceFile) {
                            try {
                                // 1. 检查服务器是否存在
                                const checkUrl = `${baseUrl}/v1/check/audio?file_name=${encodeURIComponent(char.voiceFile)}`;
                                const checkRes = await fetch(checkUrl);
                                let exists = false;
                                if (checkRes.ok) {
                                    const checkData = await checkRes.json();
                                    exists = checkData.exists;
                                }

                                // 2. 如果不存在，则上传
                                if (!exists) {
                                    // console.log(`正在自动上传音色: ${char.voiceFile}`);
                                    const formData = new FormData();
                                    formData.append('audio', voiceFile, char.voiceFile);
                                    formData.append('full_path', char.voiceFile);
                                    await fetch(`${baseUrl}/v1/upload_audio`, { method: 'POST', body: formData });
                                }
                            } catch (e) {
                                console.warn('自动上传音色文件失败，尝试直接合成:', e);
                            }
                        }

                        const synthRes = await fetch(`${baseUrl}/v2/synthesize`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!synthRes.ok) {
                            const errText = await synthRes.text();
                            throw new Error(`语音合成失败: ${errText}`);
                        }

                        const blob = await synthRes.blob();
                        // Save generated audio to DB
                        await saveAssetToDB(`line_audio_${line.id}`, blob);
                        const audioUrl = URL.createObjectURL(blob);
                        
                        line.audioUrl = audioUrl;
                        // 重置剪辑点
                        line.trimStart = 0;
                        line.trimEnd = 1;

                    } catch (e) {
                        alert(e.message);
                        console.error(e);
                    } finally {
                        line.isGenerating = false;
                    }
                };

                const generateAllLines = async () => {
                    // Pre-flight check: 只要有一条没绑定音源，就终止
                    for (const [index, line] of scriptLines.value.entries()) {
                        if (line.type === 'dialogue') {
                            const char = characters.value.find(c => c.name === line.role);
                            if (!char || !char.voiceFile) {
                                alert(`一键生成已终止。\n\n原因：第 ${index + 1} 行台词的角色（${line.role}）没有绑定音源。\n\n请在左侧的“角色列表”中为该角色选择一个有效的音色文件。`);
                                return; // Abort the entire process
                            }
                        }
                    }

                    if (!confirm(`检查通过！即将为 ${scriptLines.value.filter(l => l.type === 'dialogue').length} 条台词生成音频，这可能会消耗大量资源。确定继续吗？`)) return;

                    isGeneratingAll.value = true;
                    let failedCount = 0;

                    try {
                        // 改为顺序执行，避免并发导致服务器 504/500 错误
                        for (const line of scriptLines.value) {
                            if (line.type === 'dialogue') {
                                await generateLineAudio(line);
                                // 如果生成后没有 audioUrl，说明失败了
                                if (!line.audioUrl) failedCount++;
                            }
                        }

                        if (failedCount > 0) {
                             alert(`一键生成完成，但有 ${failedCount} 条台词生成失败。请检查控制台或单独重新生成失败的台词。`);
                        } else {
                            await saveProjectToDB(); // 强制保存一次项目状态
                            alert('所有台词音频已成功生成！');
                        }

                    } catch (e) {
                        console.error("生成全部音频时发生意外错误:", e);
                        alert('生成过程中出现未知错误，详情请查看控制台。');
                    } finally {
                        isGeneratingAll.value = false;
                    }
                };

                const playLineAudio = (line, stopPreviousSfx = true) => {
                    return new Promise(async (resolve, reject) => {
                        try {
                        // 1. Resume AudioContext if it's suspended
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }

                        // 2. Stop anything currently playing
                        if (dialogueSource) {
                            dialogueSource.onended = null; // Prevent onended from firing on manual stop
                            dialogueSource.stop();
                            dialogueSource = null;
                        }
                        
                        if (playbackAnimationFrame) {
                            cancelAnimationFrame(playbackAnimationFrame);
                            playbackAnimationFrame = null;
                        }
                        
                        if (stopPreviousSfx) {
                            sfxSources.forEach(source => { try { source.stop(); } catch(e){} });
                            sfxSources = [];
                        }

                        // If it was a stop request (clicking the same line in manual mode)
                        if (isAuditioningId.value === line.id) {
                            isAuditioningId.value = null;
                            return resolve();
                        }

                        if (!line.audioUrl) return resolve(); // Resolve silently if no audio

                        isAuditioningId.value = line.id;

                        // 3. Prepare loading promises (Parallel loading)
                        const loadDialogue = async () => {
                            const res = await fetch(line.audioUrl);
                            const ab = await res.arrayBuffer();
                            return await audioContext.decodeAudioData(ab);
                        };

                        const loadSfx = async () => {
                            if (!line.sfx || line.sfx.length === 0) return [];
                            const promises = line.sfx.map(async (sfxItem) => {
                                    const sfxLibItem = sfxLibrary.value.find(s => s.name === sfxItem.name);
                                    if (sfxLibItem && sfxLibItem.filename) {
                                        const buf = await loadAudioBuffer(sfxLibItem.filename);
                                        if (buf) return { buffer: buf, item: sfxItem };
                                    }
                                    return null;
                            });
                            const results = await Promise.all(promises);
                            return results.filter(r => r !== null);
                        };

                        // 4. Execute loads in parallel
                        const [dialogueBuffer, sfxBuffers] = await Promise.all([
                            loadDialogue(),
                            loadSfx()
                        ]);

                        // 5. Set up dialogue
                            dialogueSource = audioContext.createBufferSource();
                            dialogueSource.buffer = dialogueBuffer;

                            // 计算剪辑参数
                            const trimStart = line.trimStart || 0;
                            const trimEnd = line.trimEnd || 1;
                            const duration = dialogueBuffer.duration;
                            const startTimeOffset = duration * trimStart;
                            const playDuration = duration * (trimEnd - trimStart);

                            const dialogueGain = audioContext.createGain();
                            dialogueGain.gain.setValueAtTime(line.dialogueVolume ?? 1.0, audioContext.currentTime);

                            // --- Filter Logic ---
                            let lastNode = dialogueSource;
                            
                            if (line.filter) {
                                const filterConfig = filterLibrary.value.find(f => f.name === line.filter);
                                if (filterConfig) {
                                    if (filterConfig.type === 'distortion') {
                                        const waveShaper = audioContext.createWaveShaper();
                                        waveShaper.curve = makeDistortionCurve(filterConfig.gain);
                                        waveShaper.oversample = '4x';
                                        lastNode.connect(waveShaper);
                                        lastNode = waveShaper;
                                    } else {
                                        const biquad = audioContext.createBiquadFilter();
                                        biquad.type = filterConfig.type;
                                        biquad.frequency.value = filterConfig.frequency;
                                        biquad.Q.value = filterConfig.Q;
                                        lastNode.connect(biquad);
                                        lastNode = biquad;
                                    }
                                }
                            }

                            // Connect to gain then destination
                            lastNode.connect(dialogueGain).connect(audioContext.destination);
                            
                            const now = audioContext.currentTime + 0.05; // Slight delay for sync
                            
                            // 6. Schedule SFX
                            sfxBuffers.forEach(({ buffer, item }) => {
                                const originalDuration = dialogueBuffer.duration;
                                const absStart = originalDuration * trimStart;
                                const absEnd = originalDuration * trimEnd;
                                const pos = parseFloat(item.position) || 0;
                                const absSfxTime = originalDuration * pos;

                                if (absSfxTime >= absStart && absSfxTime <= absEnd) {
                                    const sSrc = audioContext.createBufferSource();
                                    sSrc.buffer = buffer;
                                    const sGain = audioContext.createGain();
                                    sGain.gain.setValueAtTime(line.sfxVolume ?? 0.5, now);
                                    sSrc.connect(sGain).connect(audioContext.destination);
                                    
                                    const relativeStart = absSfxTime - absStart;
                                    sSrc.start(now + relativeStart);
                                    
                                    sfxSources.push(sSrc);
                                    sSrc.onended = () => {
                                        const idx = sfxSources.indexOf(sSrc);
                                        if (idx > -1) sfxSources.splice(idx, 1);
                                    };
                                }
                            });

                            // 7. Play dialogue
                            dialogueSource.onended = async () => {
                                // This event fires on natural end or manual .stop()
                                if (playbackAnimationFrame) {
                                    cancelAnimationFrame(playbackAnimationFrame);
                                    playbackAnimationFrame = null;
                                }
                                if (isAuditioningId.value === line.id) {
                                    isAuditioningId.value = null;
                                }
                                resolve();
                            };
                            
                            dialogueSource.start(now, startTimeOffset, playDuration);
                            
                            // 启动进度条动画
                            const updateProgress = () => {
                                if (isAuditioningId.value !== line.id) return;
                                const elapsed = audioContext.currentTime - now;
                                if (elapsed >= 0) {
                                    // 计算当前在整个文件中的百分比位置
                                    // 当前位置 = (startTimeOffset + elapsed) / totalDuration
                                    // startTimeOffset = duration * trimStart
                                    // => (duration * trimStart + elapsed) / duration
                                    // => trimStart + (elapsed / duration)
                                    const progress = trimStart + (elapsed / duration);
                                    playbackProgress.value = Math.min(progress, trimEnd);
                                } else {
                                    playbackProgress.value = trimStart;
                                }
                                
                                if (audioContext.currentTime < now + playDuration) {
                                    playbackAnimationFrame = requestAnimationFrame(updateProgress);
                                } else {
                                    playbackProgress.value = trimEnd;
                                }
                            };
                            playbackAnimationFrame = requestAnimationFrame(updateProgress);

                        } catch (e) {
                            console.error("Failed to play audio:", e);
                            // alert('播放音频失败，请检查文件或网络。'); // Suppress alert for smoother UX
                            isAuditioningId.value = null;
                            resolve(); // Resolve to not block sequence
                        }
                    });
                };

                // --- 存档管理逻辑 ---
                const blobToBase64 = (blob) => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                };

                const base64ToBlob = (base64, mimeType) => {
                    const byteString = atob(base64.split(',')[1]);
                    const ab = new ArrayBuffer(byteString.length);
                    const ia = new Uint8Array(ab);
                    for (let i = 0; i < byteString.length; i++) {
                        ia[i] = byteString.charCodeAt(i);
                    }
                    return new Blob([ab], { type: mimeType });
                };

                const exportScriptState = async () => {
                    if (!confirm('即将导出包含所有素材（音效、BGM、音色）的完整工程文件。如果素材较多，文件可能较大，请耐心等待。')) return;

                    isExportingProject.value = true;
                    exportStatus.value = '准备中...';

                    try {
                    // 1. 处理资源库 (嵌入音频文件)
                    const processLibrary = async (lib, fileKey) => {
                        const processed = [];
                        for (let i = 0; i < lib.length; i++) {
                            const item = lib[i];
                            // 进度提示 & 让出主线程防止卡死
                            if (i % 5 === 0) {
                                exportStatus.value = `打包资源 ${i}/${lib.length}`;
                                await new Promise(r => setTimeout(r, 0));
                            }

                            const itemCopy = { ...item };
                            const filename = item[fileKey];
                            if (filename) {
                                let blob = null;
                                // 1. 优先从内存 Map 获取 (File 对象)
                                if (localFileMap.value.has(filename)) {
                                    blob = localFileMap.value.get(filename);
                                }
                                // 2. 如果内存没有，尝试从 IndexedDB 读取 (Blob)
                                if (!blob) {
                                    blob = await loadAssetFromDB(filename);
                                }
                                
                                if (blob) {
                                try {
                                    itemCopy._fileData = await blobToBase64(blob);
                                    itemCopy._mimeType = blob.type;
                                } catch (e) {
                                    console.warn(`Failed to embed file: ${filename}`, e);
                                }
                                }
                            }
                            processed.push(itemCopy);
                        }
                        return processed;
                    };

                    const sfxExport = await processLibrary(sfxLibrary.value, 'filename');
                    const bgmExport = await processLibrary(bgmLibrary.value, 'filename');
                    const timbreExport = await processLibrary(timbres.value, 'refPath');

                    // 将音频转换为 Base64 以便保存
                    const linesToSave = [];
                    const totalLines = scriptLines.value.length;
                    
                    for (let i = 0; i < totalLines; i++) {
                        const line = scriptLines.value[i];
                        
                        if (i % 5 === 0) {
                            exportStatus.value = `打包台词 ${i}/${totalLines}`;
                            await new Promise(r => setTimeout(r, 0));
                        }

                        const lineCopy = { ...line };
                        lineCopy.isGenerating = false; // 清理状态
                        
                        // 尝试获取音频 Blob (优先 fetch URL，失败则查 DB)
                        let blob = null;
                        if (line.audioUrl) {
                            try {
                                const res = await fetch(line.audioUrl);
                                blob = await res.blob();
                            } catch (e) { /* ignore */ }
                        }
                        
                        if (!blob && line.type === 'dialogue') {
                            blob = await loadAssetFromDB(`line_audio_${line.id}`);
                        }

                        if (blob) {
                            try {
                                lineCopy.audioBase64 = await blobToBase64(blob);
                                lineCopy.audioUrl = ''; // 导出时不保存 blob URL
                            } catch (e) {
                                console.warn('导出音频失败:', line.id, e);
                            }
                        }
                        linesToSave.push(lineCopy);
                    }

                    exportStatus.value = '生成文件...';
                    await new Promise(r => setTimeout(r, 50)); // 给 UI 一点时间刷新

                    const data = {
                        version: '2.0',
                        timestamp: new Date().toISOString(),
                        // 资源库
                        libraries: {
                            sfx: sfxExport,
                            bgm: bgmExport,
                            timbres: timbreExport,
                            filters: filterLibrary.value,
                            emotions: emotionPresets.value
                        },
                        // 项目状态
                        project: {
                            rawScript: rawScript.value,
                            rawAnalysisResult: rawAnalysisResult.value,
                            emotionIntensity: emotionIntensity.value,
                            characters: characters.value,
                            scriptLines: linesToSave
                        }
                    };
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const now = new Date();
                    const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
                    a.download = `Unitale工程文件_${timestamp}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error(e);
                        alert('导出失败: ' + e.message);
                    } finally {
                        isExportingProject.value = false;
                        exportStatus.value = '';
                    }
                };

                const triggerImport = () => {
                    importFileRef.value.click();
                };

                const handleImportFile = (event) => {
                    const file = event.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            isExportingProject.value = true; // 复用 loading 状态
                            exportStatus.value = '解析中...';

                            const data = JSON.parse(e.target.result);
                            const assetsToSave = []; // 用于批量收集待保存的音频文件
                            
                            // 辅助函数：恢复资源库文件
                            const restoreLibraryFiles = async (libItems, fileKey) => {
                                if (!libItems) return [];
                                const restoredItems = [];
                                for (const item of libItems) {
                                    if (item._fileData) {
                                        try {
                                            const blob = base64ToBlob(item._fileData, item._mimeType || 'audio/wav');
                                            const file = new File([blob], item[fileKey], { type: item._mimeType || 'audio/wav' });
                                            localFileMap.value.set(item[fileKey], file);
                                            
                                            // 优化：收集到批量列表，稍后统一保存
                                            assetsToSave.push({ key: item[fileKey], blob: file });

                                            // 预加载到缓存
                                            loadAudioBuffer(item[fileKey]);
                                            
                                            delete item._fileData;
                                            delete item._mimeType;
                                        } catch (err) {
                                            console.warn(`Failed to restore file: ${item[fileKey]}`, err);
                                        }
                                    }
                                    restoredItems.push(item);
                                }
                                return restoredItems;
                            };

                            if (data.version === '2.0' || data.project) {
                                // v2.0 完整工程格式
                                if (!confirm('检测到完整工程文件。导入将覆盖当前的【资源库和脚本】（模型配置不会被覆盖）。确定继续吗？')) return;

                                // --- 清空当前数据 ---
                                rawScript.value = '';
                                rawAnalysisResult.value = '';
                                characters.value = [];
                                scriptLines.value = [];
                                sfxLibrary.value = [];
                                bgmLibrary.value = [];
                                timbres.value = [];
                                filterLibrary.value = [];
                                emotionPresets.value = [];
                                localFileMap.value.clear();
                                audioBufferCache.clear();

                                // 2. 恢复资源库
                                if (data.libraries) {
                                    sfxLibrary.value = await restoreLibraryFiles(data.libraries.sfx, 'filename');
                                    bgmLibrary.value = await restoreLibraryFiles(data.libraries.bgm, 'filename');
                                    timbres.value = await restoreLibraryFiles(data.libraries.timbres, 'refPath');
                                    filterLibrary.value = data.libraries.filters || [];
                                    emotionPresets.value = data.libraries.emotions || [];

                                    // 不再调用 save*ToLocal，因为数据仅在内存中
                                    
                                    // 4. 同步音色到服务器
                                    await syncTimbresWithServer();
                                    // await syncTimbresWithServer(); // 移除导入时的自动同步，改为生成时按需上传
                                }

                                // 3. 恢复项目状态
                                const proj = data.project;
                                rawScript.value = proj.rawScript || '';
                                rawAnalysisResult.value = proj.rawAnalysisResult || '';
                                emotionIntensity.value = proj.emotionIntensity || 5;
                                characters.value = proj.characters || [];

                                // 恢复台词音频
                                exportStatus.value = '恢复台词音频...';
                                const restoredLines = [];
                                for (let i = 0; i < proj.scriptLines.length; i++) {
                                    const line = proj.scriptLines[i];
                                    if (i % 20 === 0) exportStatus.value = `恢复台词 ${i}/${proj.scriptLines.length}`;
                                    
                                    if (line.audioBase64) {
                                        try {
                                            const res = await fetch(line.audioBase64);
                                            const blob = await res.blob();
                                            
                                            // 优化：收集到批量列表
                                            assetsToSave.push({ key: `line_audio_${line.id}`, blob: blob });

                                            line.audioUrl = URL.createObjectURL(blob);
                                            delete line.audioBase64; // 清理内存
                                        } catch (err) { console.warn('Audio restore failed', err); }
                                    }
                                    restoredLines.push(line);
                                }
                                scriptLines.value = restoredLines;
                                
                                // 执行批量保存 (一次性写入所有文件)
                                exportStatus.value = '写入数据库...';
                                if (assetsToSave.length > 0) await saveAssetsBatch(assetsToSave);
                                
                                // 强制保存一次项目状态到 DB，确保 JSON 数据也同步
                                await saveProjectToDB();
                                
                                alert('完整工程导入成功！所有资源和设置已恢复。');

                            } else if (data.scriptLines && Array.isArray(data.scriptLines)) {
                                // v1.x 旧版存档格式兼容
                                if (confirm('检测到旧版存档。确定要读取吗？当前未保存的进度将被覆盖。')) {
                                    if (data.rawScript !== undefined) rawScript.value = data.rawScript;
                                    if (data.rawAnalysisResult !== undefined) rawAnalysisResult.value = data.rawAnalysisResult;
                                    if (data.emotionIntensity !== undefined) emotionIntensity.value = data.emotionIntensity;
                                    
                                    // 修复：读取存档时，如果存档包含角色列表则直接使用，否则根据台词重建角色列表
                                    // 这样可以确保“没有的角色要删除”，并且“角色的音色选用也要保存”
                                    if (data.characters && Array.isArray(data.characters)) {
                                        characters.value = data.characters;
                                    } else {
                                        // 兼容旧存档：从台词中提取角色
                                        const roles = new Set();
                                        data.scriptLines.forEach(l => {
                                            if (l.type === 'dialogue' && l.role) roles.add(l.role);
                                        });
                                        characters.value = Array.from(roles).map(r => {
                                            const matchingTimbre = timbres.value.find(t => t.name === r);
                                            return {
                                                id: Date.now() + Math.random().toString(),
                                                name: r,
                                                voiceFile: matchingTimbre ? matchingTimbre.refPath : ''
                                            };
                                        });
                                    }
                                    
                                    // 恢复音频数据 (Base64 -> Blob URL)
                                    exportStatus.value = '恢复旧版数据...';
                                    const restoredLines = [];
                                    for (const line of data.scriptLines) {
                                        if (line.audioBase64) {
                                            try {
                                                const res = await fetch(line.audioBase64);
                                                const blob = await res.blob();
                                                
                                                // 优化：收集到批量列表
                                                assetsToSave.push({ key: `line_audio_${line.id}`, blob: blob });

                                                line.audioUrl = URL.createObjectURL(blob);
                                                // delete line.audioBase64; // 可选：释放内存，但保留在对象中也没关系
                                            } catch (err) {
                                                console.warn('恢复音频失败:', line.id, err);
                                            }
                                        }
                                        restoredLines.push(line);
                                    }

                                    scriptLines.value = restoredLines;
                                    
                                    exportStatus.value = '保存中...';
                                    if (assetsToSave.length > 0) await saveAssetsBatch(assetsToSave);
                                    await saveProjectToDB();
                                    alert('存档读取成功！');
                                }
                            } else {
                                alert('无效的存档文件格式');
                            }
                        } catch (err) {
                            alert('读取失败: ' + err.message);
                        } finally {
                            isExportingProject.value = false;
                            exportStatus.value = '';
                        }
                        event.target.value = ''; // Reset
                    };
                    reader.readAsText(file);
                };

                // --- 导出音频逻辑 (WAV) ---
                const exportAudio = async () => {
                    const dialogueLines = scriptLines.value.filter(l => l.type === 'dialogue');
                    if (dialogueLines.length === 0) return alert('脚本为空');
                    if (dialogueLines.some(l => !l.audioUrl)) {
                        if (!confirm('部分台词尚未生成音频，导出时将被跳过。确定继续吗？')) return;
                    }

                    isExportingAudio.value = true;

                    try {
                        const assets = { dialogues: {}, sfx: {}, bgm: {} };

                        // 1. 加载所有台词音频
                        for (const line of dialogueLines) {
                            if (line.audioUrl) assets.dialogues[line.id] = await loadAudioBuffer(line.audioUrl);
                        }

                        // 2. 加载用到的音效
                        const usedSfxNames = new Set();
                        scriptLines.value.forEach(l => { if (l.sfx) l.sfx.forEach(s => usedSfxNames.add(s.name)); });
                        for (const name of usedSfxNames) {
                            const item = sfxLibrary.value.find(s => s.name === name);
                            if (item && item.filename) {
                                try { assets.sfx[name] = await loadAudioBuffer(item.filename); } catch(e) {}
                            }
                        }

                        // 3. 加载用到的 BGM
                        const usedBgmNames = new Set();
                        scriptLines.value.forEach(l => { if (l.type === 'bgm' && l.action === 'play') usedBgmNames.add(l.bgmName); });
                        for (const name of usedBgmNames) {
                            const item = bgmLibrary.value.find(b => b.name === name);
                            if (item && item.filename) {
                                try { assets.bgm[name] = await loadAudioBuffer(item.filename); } catch(e) {}
                            }
                        }

                        // 4. 计算时间轴
                        let currentTime = 0;
                        const events = [];
                        const bgmSegments = [];
                        let currentBgm = null;

                        for (const line of scriptLines.value) {
                            if (line.type === 'bgm') {
                                if (line.action === 'play') {
                                    if (currentBgm) bgmSegments.push({ ...currentBgm, end: currentTime });
                                    currentBgm = { name: line.bgmName, start: currentTime, volume: line.volume };
                                } else if (line.action === 'stop') {
                                    if (currentBgm) {
                                        bgmSegments.push({ ...currentBgm, end: currentTime });
                                        currentBgm = null;
                                    }
                                }
                            } else if (line.type === 'dialogue') {
                                const buffer = assets.dialogues[line.id];
                                if (buffer) {
                                    // 计算剪辑
                                    const trimStart = line.trimStart || 0;
                                    const trimEnd = line.trimEnd || 1;
                                    const playDuration = buffer.duration * (trimEnd - trimStart);

                                    // 模拟 playLineAudio 中的 0.05s 调度延迟，确保导出节奏与实时播放一致
                                    currentTime += 0.05;
                                    events.push({ type: 'dialogue', time: currentTime, buffer: buffer, line: line, trimStart, trimEnd, playDuration });
                                    currentTime += playDuration;
                                }
                                currentTime += (line.break_duration || 0);
                            }
                        }
                        if (currentBgm) bgmSegments.push({ ...currentBgm, end: currentTime + 2 }); // BGM 尾部淡出

                        // 5. 离线渲染
                        const totalDuration = currentTime + 1;
                        const offlineCtx = new OfflineAudioContext(2, totalDuration * 44100, 44100);

                        // 调度 BGM
                        bgmSegments.forEach(seg => {
                            const buffer = assets.bgm[seg.name];
                            if (buffer) {
                                const src = offlineCtx.createBufferSource();
                                src.buffer = buffer;
                                src.loop = true;
                                const gain = offlineCtx.createGain();
                                gain.gain.setValueAtTime(0, seg.start);
                                gain.gain.linearRampToValueAtTime(seg.volume, seg.start + 2);
                                gain.gain.setValueAtTime(seg.volume, Math.max(seg.start + 2, seg.end - 2));
                                gain.gain.linearRampToValueAtTime(0, seg.end);
                                src.connect(gain).connect(offlineCtx.destination);
                                src.start(seg.start);
                                src.stop(seg.end);
                            }
                        });

                        // 调度台词和音效
                        events.forEach(evt => {
                            const dSrc = offlineCtx.createBufferSource();
                            dSrc.buffer = evt.buffer;
                            const dGain = offlineCtx.createGain();
                            dGain.gain.value = evt.line.dialogueVolume ?? 1.0;

                            const offset = evt.buffer.duration * evt.trimStart;
                            const duration = evt.playDuration;

                            let lastNode = dSrc;
                            // 应用滤镜
                            if (evt.line.filter) {
                                const fConfig = filterLibrary.value.find(f => f.name === evt.line.filter);
                                if (fConfig) {
                                    if (fConfig.type === 'distortion') {
                                        const ws = offlineCtx.createWaveShaper();
                                        ws.curve = makeDistortionCurve(fConfig.gain);
                                        ws.oversample = '4x';
                                        lastNode.connect(ws);
                                        lastNode = ws;
                                    } else {
                                        const bq = offlineCtx.createBiquadFilter();
                                        bq.type = fConfig.type;
                                        bq.frequency.value = fConfig.frequency;
                                        bq.Q.value = fConfig.Q;
                                        lastNode.connect(bq);
                                        lastNode = bq;
                                    }
                                }
                            }
                            lastNode.connect(dGain).connect(offlineCtx.destination);
                            dSrc.start(evt.time, offset, duration);

                            // 调度音效
                            if (evt.line.sfx) {
                                evt.line.sfx.forEach(s => {
                                    const sBuffer = assets.sfx[s.name];
                                    if (sBuffer) {
                                        const originalDuration = evt.buffer.duration;
                                        const absStart = originalDuration * evt.trimStart;
                                        const absEnd = originalDuration * evt.trimEnd;
                                        const pos = parseFloat(s.position) || 0;
                                        const absSfxTime = originalDuration * pos;

                                        if (absSfxTime >= absStart && absSfxTime <= absEnd) {
                                        const sSrc = offlineCtx.createBufferSource();
                                        sSrc.buffer = sBuffer;
                                        const sGain = offlineCtx.createGain();
                                        sGain.gain.value = evt.line.sfxVolume ?? 0.5;
                                        sSrc.connect(sGain).connect(offlineCtx.destination);
                                        
                                        const relativeStart = absSfxTime - absStart;
                                        sSrc.start(evt.time + relativeStart);
                                        }
                                    }
                                });
                            }
                        });

                        const renderedBuffer = await offlineCtx.startRendering();
                        const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
                        const url = URL.createObjectURL(wavBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `storyforge_export_${Date.now()}.wav`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                    } catch(e) {
                        console.error(e);
                        alert('导出失败: ' + e.message);
                    } finally {
                        isExportingAudio.value = false;
                    }
                };

                // 辅助函数：AudioBuffer 转 WAV Blob
                function bufferToWave(abuffer, len) {
                    const numOfChan = abuffer.numberOfChannels;
                    const length = len * numOfChan * 2 + 44;
                    const buffer = new ArrayBuffer(length);
                    const view = new DataView(buffer);
                    const channels = [];
                    let i, sample;
                    let offset = 0;
                    let pos = 0;

                    function setUint16(data) { view.setUint16(offset, data, true); offset += 2; }
                    function setUint32(data) { view.setUint32(offset, data, true); offset += 4; }

                    setUint32(0x46464952); // "RIFF"
                    setUint32(length - 8); // file length - 8
                    setUint32(0x45564157); // "WAVE"
                    setUint32(0x20746d66); // "fmt " chunk
                    setUint32(16); // length = 16
                    setUint16(1); // PCM (uncompressed)
                    setUint16(numOfChan);
                    setUint32(abuffer.sampleRate);
                    setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
                    setUint16(numOfChan * 2); // block-align
                    setUint16(16); // 16-bit
                    setUint32(0x61746164); // "data" - chunk
                    setUint32(length - offset - 4); // chunk length

                    for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

                    while(pos < len) {
                        for(i = 0; i < numOfChan; i++) {
                            sample = Math.max(-1, Math.min(1, channels[i][pos]));
                            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0;
                            view.setInt16(offset, sample, true);
                            offset += 2;
                        }
                        pos++;
                    }
                    return new Blob([buffer], {type: "audio/wav"});
                }

                // --- 脚本制作逻辑 ---
                const splitScript = () => {
                    if (!rawScript.value.trim()) return alert('请输入原文内容');
                    
                    let text = rawScript.value.replace(/\r\n/g, '\n');
                    const splitRegex = /\n+|(?<=[。！？!?])(?=["']?)\s*/;
                    
                    const lines = text.split(splitRegex)
                        .map(l => l.trim())
                        .filter(l => l.length > 0);

                    scriptLines.value = lines.map(text => ({
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'dialogue',
                        role: '旁白', 
                        emotion_text: '中立',
                        original_emotion_text: '中立',
                        filter: '',
                        text: text,
                        trimStart: 0,
                        trimEnd: 1,
                        sfxVolume: 0.5,
                        dialogueVolume: 1.0,
                        audioUrl: '',
                        isGenerating: false
                    }));
                };

                const addBgmBlock = () => {
                    const newBlock = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'bgm',
                        action: 'play',
                        volume: 0.4,
                        bgmName: bgmLibrary.value.length > 0 ? bgmLibrary.value[0].name : ''
                    };
                    if (selectedLineIndex.value !== -1 && selectedLineIndex.value < scriptLines.value.length) {
                        scriptLines.value.splice(selectedLineIndex.value + 1, 0, newBlock);
                        selectedLineIndex.value++;
                    } else {
                        scriptLines.value.push(newBlock);
                        selectedLineIndex.value = scriptLines.value.length - 1;
                    }
                };

                const addDialogueBlock = () => {
                    const newBlock = {
                        id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                        type: 'dialogue',
                        role: '旁白', 
                        emotion_text: '中立',
                        original_emotion_text: '中立',
                        filter: '',
                        text: '',
                        trimStart: 0,
                        trimEnd: 1,
                        sfx: [],
                        break_duration: 0,
                        sfxVolume: 0.5,
                        dialogueVolume: 1.0,
                        audioUrl: '',
                        isGenerating: false
                    };
                    if (selectedLineIndex.value !== -1 && selectedLineIndex.value < scriptLines.value.length) {
                        scriptLines.value.splice(selectedLineIndex.value + 1, 0, newBlock);
                        selectedLineIndex.value++;
                    } else {
                        scriptLines.value.push(newBlock);
                        selectedLineIndex.value = scriptLines.value.length - 1;
                    }
                };

                const removeScriptLine = (index) => {
                    scriptLines.value.splice(index, 1);
                    if (selectedLineIndex.value === index) {
                        selectedLineIndex.value = -1;
                    } else if (selectedLineIndex.value > index) {
                        selectedLineIndex.value--;
                    }
                };

                const autoResizeTextarea = (event) => {
                    const el = event.target;
                    el.style.height = 'auto';
                    el.style.height = el.scrollHeight + 'px';
                };

                const addLineSfx = (line) => {
                    if (!line.sfx) line.sfx = [];
                    const defaultSfx = sfxLibrary.value.length > 0 ? sfxLibrary.value[0].name : 'New SFX';
                    line.sfx.push({ name: defaultSfx, position: 0.5 });
                };

                const removeLineSfx = (line, index) => {
                    if (line.sfx) line.sfx.splice(index, 1);
                };

                const stopScriptSequentially = () => {
                    isSequencePlaying.value = false;
                    currentSequenceIndex.value = -1;
                    // Stop dialogue audio
                    if (dialogueSource) {
                        try { dialogueSource.stop(); } catch(e) {}
                        dialogueSource = null;
                    }
                    // Stop SFX audio
                    sfxSources.forEach(source => { try { source.stop(); } catch(e) {} });
                    sfxSources = [];
                    // Stop BGM audio
                    if (bgmAudioNode && bgmGainNode) {
                        const oldNode = bgmAudioNode;
                        const oldGain = bgmGainNode;
                        const now = audioContext.currentTime;
                        oldGain.gain.cancelScheduledValues(now);
                        oldGain.gain.setValueAtTime(oldGain.gain.value, now);
                        oldGain.gain.linearRampToValueAtTime(0, now + 2);
                        setTimeout(() => { try { oldNode.stop(); } catch(e){} }, 2000);
                        bgmAudioNode = null;
                        bgmGainNode = null;
                    }
                };

                const playBgm = async (bgmName, volume = 0.4) => {
                    // Stop any existing BGM
                    if (bgmAudioNode && bgmGainNode) {
                        const oldNode = bgmAudioNode;
                        const oldGain = bgmGainNode;
                        const now = audioContext.currentTime;
                        
                        // 淡出旧 BGM
                        oldGain.gain.cancelScheduledValues(now);
                        oldGain.gain.setValueAtTime(oldGain.gain.value, now);
                        oldGain.gain.linearRampToValueAtTime(0, now + 2);
                        
                        setTimeout(() => {
                            try { oldNode.stop(); } catch(e){}
                        }, 2000);

                        bgmAudioNode = null;
                        bgmGainNode = null;
                    }

                    const bgmLibItem = bgmLibrary.value.find(b => b.name === bgmName);
                    if (!bgmLibItem || !bgmLibItem.filename) {
                        console.warn(`BGM not found in library: ${bgmName}`);
                        return;
                    }

                    try {
                        const audioBuffer = await loadAudioBuffer(bgmLibItem.filename);
                        if (!audioBuffer) throw new Error('Load failed');
                        
                        bgmAudioNode = audioContext.createBufferSource();
                        bgmAudioNode.buffer = audioBuffer;
                        bgmAudioNode.loop = true;
                        
                        bgmGainNode = audioContext.createGain();
                        // 淡入新 BGM
                        bgmGainNode.gain.value = 0;
                        bgmGainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 2);

                        bgmAudioNode.connect(bgmGainNode).connect(audioContext.destination);
                        bgmAudioNode.start();
                    } catch (e) {
                        console.error(`Failed to load or play BGM ${bgmLibItem.filename}:`, e);
                        alert(`播放背景音乐失败: ${bgmLibItem.filename}`);
                    }
                };
                
                const playScriptSequentially = async () => {
                    stopScriptSequentially();
                    isSequencePlaying.value = true;
                    const startIndex = selectedLineIndex.value !== -1 ? selectedLineIndex.value : 0;
                    
                    for (let i = startIndex; i < scriptLines.value.length; i++) {
                        if (!isSequencePlaying.value) break; // Check if stopped
                        
                        currentSequenceIndex.value = i;
                        const line = scriptLines.value[i];

                        if (line.type === 'bgm') {
                            if (line.action === 'play') {
                                await playBgm(line.bgmName, line.volume);
                            } else if (line.action === 'stop') {
                                if (bgmAudioNode && bgmGainNode) {
                                    const oldNode = bgmAudioNode;
                                    const oldGain = bgmGainNode;
                                    const now = audioContext.currentTime;
                                    oldGain.gain.cancelScheduledValues(now);
                                    oldGain.gain.setValueAtTime(oldGain.gain.value, now);
                                    oldGain.gain.linearRampToValueAtTime(0, now + 2);
                                    setTimeout(() => { try { oldNode.stop(); } catch(e){} }, 2000);
                                    bgmAudioNode = null;
                                    bgmGainNode = null;
                                }
                            }
                        } else { // 'dialogue'
                            if (!line.audioUrl) {
                                // 跳过未生成的台词
                                continue;
                            }
                            
                            // A promise that resolves when the line finishes playing
                            await playLineAudio(line, false);

                            if (!isSequencePlaying.value) break;

                            // Handle break duration
                            if (line.break_duration > 0) {
                                await new Promise(resolve => setTimeout(resolve, line.break_duration * 1000));
                            }
                        }
                    }

                    // Reset when done or stopped
                    stopScriptSequentially();
                };

                const analyzeScript = async () => {
                    if (!currentConfig.value) return alert('请先在“模型配置”选择一个 LLM 模型配置');
                    if (!rawScript.value.trim()) return alert('请输入原文内容');

                    isAnalyzingScript.value = true;
                    
                    let sfxSection = "";
                    const enabledSfx = sfxLibrary.value.filter(s => s.enabled !== false);
                    if (enabledSfx.length > 0) {
                        const sfxList = enabledSfx.map(s => `- ${s.name}: ${s.description}`).join('\n');
                        sfxSection = `# 音效库 (Sound Effects)\n你还可以使用以下音效素材，请根据剧情需要插入：\n${sfxList}\n**注意：必须严格使用列表中的名称，严禁编造不存在的音效。**`;
                    } else {
                        sfxSection = `# 音效库 (Sound Effects)\n当前音效库为空。\n**注意：请勿生成任何 'sfx' 字段。**`;
                    }

                    let bgmSection = "";
                    const enabledBgm = bgmLibrary.value.filter(b => b.enabled !== false);
                    if (enabledBgm.length > 0) {
                        const bgmList = enabledBgm.map(s => `- ${s.name}: ${s.description}`).join('\n');
                        bgmSection = `# 背景音乐库 (Background Music)\n现有以下背景音乐素材可用：\n${bgmList}\n\n**核心指令：**\n1. 必须**逐字匹配**使用列表中的名称。\n2. 如果列表中没有适合当前剧情的音乐，**请勿生成** BGM 播放指令。\n3. **严禁编造**列表中不存在的 BGM 名称。`;
                    } else {
                        bgmSection = `# 背景音乐库 (Background Music)\n**当前背景音乐库为空 (EMPTY)。**\n\n**核心指令：**\n1. **严禁生成**任何 action="play" 的 BGM 控制块。\n2. 你只能生成 action="stop" 的指令（如果需要停止之前的音乐）。\n3. 绝对不要编造 BGM 名称。`;
                    }

                    let filterSection = "";
                    const enabledFilters = filterLibrary.value.filter(f => f.enabled !== false);
                    if (enabledFilters.length > 0) {
                        const fList = enabledFilters.map(f => `- ${f.name}: ${f.description}`).join('\n');
                        filterSection = `# 滤波器库 (Audio Filters)\n如果剧情需要特殊音效处理（如电话、水下、回忆），请使用以下滤波器：\n${fList}\n**注意：必须严格使用列表中的名称，如果没有匹配项则不要使用 filter 字段。**`;
                    } else {
                        filterSection = `# 滤波器库 (Audio Filters)\n当前滤波器库为空。\n**注意：请勿生成任何 filter 字段。**`;
                    }

                    const bgmExampleLine = enabledBgm.length > 0 
                        ? `{"type": "bgm", "action": "play", "name": "${enabledBgm[0].name}"},`
                        : '';
                    
                    const sfxExample = enabledSfx.length > 0
                        ? `, "sfx": [{"name": "${enabledSfx[0].name}", "position": 0.2}]`
                        : '';

                    const templateToUse = useCustomPrompt.value ? customPromptTemplate.value : defaultPromptTemplate;
                    let finalPrompt = templateToUse
                        .replace(/\${emotionIntensity}/g, emotionIntensity.value)
                        .replace(/\${sfxSection}/g, sfxSection)
                        .replace(/\${bgmSection}/g, bgmSection)
                        .replace(/\${filterSection}/g, filterSection)
                        .replace(/\${bgmExampleLine}/g, bgmExampleLine)
                        .replace(/\${sfxExample}/g, sfxExample)
                        .replace(/\${rawScript}/g, rawScript.value);
                    
                    try {
                        const cfg = currentConfig.value;
                        let url = cfg.baseUrl.trim().replace(/\/+$/, '');
                        if (!url.endsWith('/chat/completions')) url += '/chat/completions';

                        let body = { model: cfg.model, messages: [{ role: 'user', content: finalPrompt }], stream: false };
                        
                        if (cfg.params) {
                            try {
                                const extraParams = JSON.parse(cfg.params);
                                body = { ...body, ...extraParams };
                            } catch (e) {
                                console.warn('解析额外参数失败:', e);
                            }
                        }

                        const res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${cfg.key}` },
                            body: JSON.stringify(body)
                        });

                        if (!res.ok) throw new Error(`HTTP ${res.status}`);
                        const data = await res.json();
                        const content = data.choices[0]?.message?.content || '';
                        rawAnalysisResult.value = content; // 保存原始输出
                        const jsonMatch = content.match(/\[\s*\{[\s\S]*\}\s*\]/);
                        const jsonStr = jsonMatch ? jsonMatch[0] : content.replace(/```json/g, '').replace(/```/g, '').trim();
                        
                        const parsed = JSON.parse(jsonStr);
                        if (Array.isArray(parsed)) {
                            // 移除拦截逻辑，完全信任 Prompt (或允许用户手动修正幻觉)
                            const validParsed = parsed;

                            const newRoles = new Set();
                            validParsed.forEach(item => {
                                const r = item.role_name || item.role;
                                if (r) newRoles.add(r);
                            });
                            
                            // 重新构建角色列表：清空并填充 (保留已有角色的音色配置)
                            const newCharacterList = [];
                            newRoles.forEach(rName => {
                                const existing = characters.value.find(c => c.name === rName);
                                let voiceFile = '';
                                let id = Date.now() + Math.random().toString();

                                if (existing) {
                                    voiceFile = existing.voiceFile;
                                    id = existing.id;
                                } else {
                                    const matchingTimbre = timbres.value.find(t => t.name === rName);
                                    if (matchingTimbre) voiceFile = matchingTimbre.refPath;
                                }
                                
                                newCharacterList.push({
                                    id: id,
                                    name: rName,
                                    voiceFile: voiceFile
                                });
                            });
                            characters.value = newCharacterList;

                            scriptLines.value = validParsed.map(item => {
                                // 通用模糊匹配函数
                                const findBestMatch = (target, library) => {
                                    if (!target) return '';
                                    const t = target.trim().toLowerCase();
                                    // 1. 精确匹配
                                    const exact = library.find(i => i.name.toLowerCase() === t);
                                    if (exact) return exact.name;
                                    
                                    // 2. 模糊匹配 (包含关系)
                                    const candidates = library.filter(i => {
                                        const n = i.name.toLowerCase();
                                        return n.includes(t) || t.includes(n);
                                    });
                                    
                                    if (candidates.length > 0) {
                                        // 按长度差排序，找最接近的
                                        candidates.sort((a, b) => Math.abs(a.name.length - target.length) - Math.abs(b.name.length - target.length));
                                        return candidates[0].name;
                                    }
                                    return '';
                                };

                                // 1. 匹配滤波器
                                let matchedFilter = '';
                                if (item.filter) {
                                    matchedFilter = findBestMatch(item.filter, filterLibrary.value);
                                }

                                // 2. 匹配音效
                                let matchedSfx = [];
                                if (item.sfx && Array.isArray(item.sfx)) {
                                    matchedSfx = item.sfx.map(s => ({
                                        name: findBestMatch(s.name, sfxLibrary.value) || s.name,
                                        position: s.position
                                    }));
                                }

                                // 3. 匹配 BGM
                                let matchedBgmName = '';
                                if (item.type === 'bgm' && item.action === 'play') {
                                    const rawName = item.name || item.bgmName || '';
                                    matchedBgmName = findBestMatch(rawName, bgmLibrary.value) || rawName;
                                }

                                return {
                                    id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                                    type: item.type || 'dialogue',
                                    // Dialogue fields
                                    role: item.role_name || item.role || '旁白',
                                    text: item.text_content || item.text || item.content || '',
                                    emotion_text: item.emotion_text || item.emotion || '中立',
                                    original_emotion_text: item.emotion_text || item.emotion || '中立',
                                    filter: matchedFilter,
                                    sfx: matchedSfx,
                                    break_duration: typeof item.break_duration === 'number' ? item.break_duration : 0,
                                    trimStart: 0,
                                    trimEnd: 1,
                                    sfxVolume: 0.5,
                                    dialogueVolume: 1.0,
                                    audioUrl: '',
                                    isGenerating: false,
                                    // BGM fields
                                    action: item.action || 'play',
                                    volume: 0.4,
                                    bgmName: matchedBgmName
                                };
                            });
                        } else {
                            alert('AI 返回格式异常，请重试');
                        }
                    } catch (e) {
                        console.error(e);
                        alert('分析失败: ' + e.message);
                    } finally {
                        isAnalyzingScript.value = false;
                    }
                };

                // --- 聊天逻辑 ---
                const clearAll = () => {
                    result.value = '';
                    reasoning.value = '';
                    error.value = '';
                };

                const stopGeneration = () => {
                    if (abortController.value) {
                        abortController.value.abort();
                        abortController.value = null;
                        loading.value = false;
                    }
                };

                const send = async () => {
                    if (!currentConfig.value) return alert('请先选择一个有效的模型配置');
                    const cfg = currentConfig.value;
                    
                    loading.value = true;
                    result.value = '';
                    reasoning.value = '';
                    error.value = '';

                    abortController.value = new AbortController();
                    
                    try {
                        let url = cfg.baseUrl.trim().replace(/\/+$/, '');
                        
                        if (!url.endsWith('/chat/completions')) {
                            url += '/chat/completions';
                        }

                        let body = {
                            model: cfg.model,
                            messages: [{ role: 'user', content: prompt.value }],
                            stream: true
                        };

                        if (cfg.params) {
                            try {
                                const extraParams = JSON.parse(cfg.params);
                                body = { ...body, ...extraParams };
                            } catch (e) {
                                console.warn('解析额外参数失败:', e);
                            }
                        }

                        const res = await fetch(url, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${cfg.key}`
                            },
                            body: JSON.stringify(body),
                            signal: abortController.value.signal
                        });

                        if (!res.ok) {
                            const errData = await res.text();
                            throw new Error(`HTTP ${res.status}: ${errData}`);
                        }

                        const reader = res.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = "";

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // 保持最后一行完整

                            for (const line of lines) {
                                const cleanLine = line.replace(/^data: /, '').trim();
                                if (!cleanLine || cleanLine === '[DONE]') continue;

                                try {
                                    const json = JSON.parse(cleanLine);
                                    const delta = json.choices[0]?.delta;
                                    
                                    if (delta?.reasoning_content) {
                                        reasoning.value += delta.reasoning_content;
                                    }
                                    if (delta?.content) {
                                        result.value += delta.content;
                                    }
                                } catch (e) {
                                    // 忽略部分解析错误
                                }
                            }
                        }
                    } catch (e) { 
                        if (e.name === 'AbortError') {
                            // 用户手动停止，不报错
                        } else {
                            error.value = e.message;
                            if (e.message.includes('Failed to fetch')) {
                                error.value += "\n\n检测到跨域(CORS)限制！Gemini API 通常禁止从浏览器前端直接调用。\n建议：开启浏览器 CORS 插件，或使用后端中转。";
                            }
                        }
                    } finally { 
                        loading.value = false; 
                        abortController.value = null;
                    }
                };

                // --- TTS 逻辑 (SonicVale 协议) ---
                
                const handleFileUpload = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        ttsRefFile.value = file;
                        if (!ttsRefPath.value || ttsRefPath.value === 'uploaded/ref.wav') {
                            ttsRefPath.value = `uploaded/${file.name}`;
                        }
                    }
                };

                const stopTtsGeneration = () => {
                    if (ttsAbortController.value) {
                        ttsAbortController.value.abort();
                        ttsAbortController.value = null;
                        ttsLoading.value = false;
                    }
                };

                const synthesizeAudio = async () => {
                    if (!currentTtsConfig.value) return alert('请选择 TTS 配置');
                    const textToSpeak = result.value || prompt.value;
                    if (!textToSpeak) return alert('没有可合成的文本 (请先对话或输入提示词)');
                    if (!ttsRefPath.value) return alert('请指定参考音频路径 ID');

                    ttsLoading.value = true;
                    ttsError.value = '';
                    audioUrl.value = '';

                    ttsAbortController.value = new AbortController();

                    const cfg = currentTtsConfig.value;
                    const baseUrl = cfg.baseUrl.trim().replace(/\/+$/, '');

                    try {
                        // 1. 检查音频是否存在
                        const checkUrl = `${baseUrl}/v1/check/audio?file_name=${encodeURIComponent(ttsRefPath.value)}`;
                        const checkRes = await fetch(checkUrl, { signal: ttsAbortController.value.signal });
                        if (!checkRes.ok) throw new Error(`Check failed: ${checkRes.status}`);
                        const checkData = await checkRes.json();

                        // 2. 上传逻辑：如果用户选择了文件，强制上传（覆盖）；否则检查服务端是否存在
                        // 修改：即使服务端存在，只要用户选了新文件，就强制上传，防止文件内容不一致或服务端文件损坏
                        if (ttsRefFile.value) {
                            const formData = new FormData();
                            formData.append('audio', ttsRefFile.value);
                            formData.append('full_path', ttsRefPath.value);

                            const uploadRes = await fetch(`${baseUrl}/v1/upload_audio`, {
                                method: 'POST',
                                body: formData,
                                signal: ttsAbortController.value.signal
                            });
                            
                            if (!uploadRes.ok) throw new Error(`Upload failed: ${uploadRes.status}`);
                        } else if (!checkData.exists) {
                            throw new Error(`服务端未找到音频 "${ttsRefPath.value}"，且未选择本地文件进行上传。`);
                        }

                        // 3. 合成语音
                        const synthPayload = {
                            text: textToSpeak,
                            audio_path: ttsRefPath.value,
                            emo_text: ttsEmoText.value || '中立'
                        };

                        const synthRes = await fetch(`${baseUrl}/v2/synthesize`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(synthPayload),
                            signal: ttsAbortController.value.signal
                        });

                        if (!synthRes.ok) {
                            const errText = await synthRes.text();
                            throw new Error(`Synthesis failed: ${errText}`);
                        }

                        // 4. 处理二进制音频流
                        const blob = await synthRes.blob();
                        audioUrl.value = URL.createObjectURL(blob);

                    } catch (e) {
                        if (e.name === 'AbortError') {
                            // 用户手动停止
                        } else {
                            console.error(e);
                            ttsError.value = e.message;
                        }
                    } finally {
                        ttsLoading.value = false;
                        ttsAbortController.value = null;
                    }
                };

                const savePrompt = () => {
                    localStorage.setItem('storyforge_prompt_template', customPromptTemplate.value);
                    localStorage.setItem('storyforge_use_custom_prompt', JSON.stringify(useCustomPrompt.value));
                    alert('Prompt 设置已保存');
                };

                const resetPrompt = () => {
                    if(confirm('确定要恢复默认 Prompt 吗？')) {
                        customPromptTemplate.value = defaultPromptTemplate;
                    }
                };

                return { 
                    // State
                    activeTab, llmConfigs, currentConfigId, 
                    form, isEditing,
                    filterLibrary, filterForm, isEditingFilter, saveFilter, editFilter, deleteFilter, resetFilterForm,
                    prompt, result, reasoning, error, loading,
                    
                    // TTS State
                    currentTtsConfigId, ttsConfigs, ttsRefPath, ttsEmoText,
                    audioUrl, ttsLoading, ttsError,
                    
                    // TTS Actions
                    handleFileUpload, synthesizeAudio, stopTtsGeneration,

                    // Actions
                    saveConfig, editConfig, deleteConfig, resetForm,
                    // TTS Actions
                    ttsForm, isEditingTts,
                    saveTtsConfig, editTtsConfig, deleteTtsConfig, resetTtsForm,
                    
                    // Character Actions (New)
                    characters, addCharacter, deleteCharacter,

                    // Timbre Actions
                    timbres, timbreForm, isEditingTimbre, selectedTimbreId,
                    saveTimbre, editTimbre, deleteTimbre, resetTimbreForm, handleTimbreFileUpload,

                    // Emotion Actions
                    emotionPresets, emotionForm, isEditingEmotion,
                    saveEmotion, editEmotion, deleteEmotion, resetEmotionForm, getPresetId, applyPresetToLine, getEmotionSelectValue, resetEmotionsToDefault,

                    // SFX Actions
                    sfxLibrary, sfxForm, isEditingSfx,
                    saveSfx, editSfx, deleteSfx, resetSfxForm, handleSfxFileUpload,
                    addLineSfx, removeLineSfx,

                    // BGM Actions
                    bgmLibrary, bgmForm, isEditingBgm,
                    saveBgm, editBgm, deleteBgm, resetBgmForm, handleBgmFileUpload,

                    // Audition Actions
                    availableRoles, isAuditioningId, generateLineAudio, playLineAudio,

                    playPreview, previewPlayingFile,
                    send, stopGeneration, clearAll,

                    playbackProgress, // Export for template

                    // Script Actions
                    rawScript, scriptLines, splitScript, removeScriptLine, autoResizeTextarea, analyzeScript, isAnalyzingScript, rawAnalysisResult, emotionIntensity,
                    addBgmBlock, addDialogueBlock, selectedLineIndex,
                    drawWaveform, startDragTrim, // Exported for template
                    generateAllLines, isGeneratingAll,
                    moveLineUp, moveLineDown,
                    exportScriptState, triggerImport, handleImportFile, importFileRef, exportAudio, isExportingAudio, 
                    isExportingProject, exportStatus,
                    playScriptSequentially, stopScriptSequentially, isSequencePlaying, currentSequenceIndex,

                    customPromptTemplate, useCustomPrompt, savePrompt, resetPrompt,
                };
            }
        }).mount('#app');
    </script>
</body>
</html>             